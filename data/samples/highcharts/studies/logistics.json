{"js":"/**\n * An advanced example of how to use a gantt chart to plan and visualize\n * resources in logistics, in this case shipping.\n * The chart displays a set of vessels and its scheduled journeys.\n * The journeys can consist of one or more laps, which in itself contains\n * loading, voyage, and unloading, these can be moved or resized.\n * The chart also includes custom indicators like the Heat Indicator which\n * displays when the vessels idle time goes above a threshold, and the\n * Earliest Possible Return Indicator which displays when the vessel can return\n * if it travels by maximum speed.\n */\n\n/**\n * --- Logistics module start\n * This module adds heat indicators, idle time, and earliest possible return\n * indicators.\n */\n(function (Highcharts) {\n    var draw = (function () {\n        var isFn = function (x) {\n            return typeof x === 'function';\n        };\n\n        /**\n         * draw - Handles the drawing of a point.\n         * TODO: add type checking.\n         *\n         * @param  {Object} params Parameters.\n         * @return {undefined} Returns undefined.\n         */\n        var draw = function draw(params) {\n            var point = this,\n                graphic = point.graphic,\n                animate = params.animate,\n                attr = params.attr,\n                onComplete = params.onComplete,\n                css = params.css || {},\n                group = params.group,\n                renderer = params.renderer,\n                shape = params.shapeArgs,\n                type = params.shapeType;\n\n            if (point.shouldDraw()) {\n                if (!graphic) {\n                    point.graphic = graphic = renderer[type](shape).add(group);\n                }\n                graphic.css(css).attr(attr)\n                    .animate(animate, undefined, onComplete);\n            } else if (graphic) {\n                graphic.animate(animate, undefined, function () {\n                    point.graphic = graphic = graphic.destroy();\n                    if (isFn(onComplete)) {\n                        onComplete();\n                    }\n                });\n            }\n            if (graphic) {\n                graphic.addClass(point.getClassName(), true);\n            }\n        };\n        return draw;\n    }());\n\n    var renderHeatIndicators = (function (Highcharts, draw) {\n\n        var extend = Highcharts.extend,\n            isFunction = function (x) {\n                return typeof x === 'function';\n            },\n            isNumber = Highcharts.isNumber,\n            merge = Highcharts.merge,\n            objectEach = Highcharts.objectEach;\n\n        var defaultOptions = {\n            color: {\n                linearGradient: {\n                    x1: 0,\n                    x2: 1,\n                    y1: 0,\n                    y2: 0\n                },\n                stops: [\n                    [0, 'rgb(255, 255, 255)'],\n                    [0.8, 'rgb(255, 0, 0)']\n                ]\n            }\n        };\n\n        var HeatIndicator = function (params) {\n            var indicator = this;\n            indicator.init(params);\n            return indicator;\n        };\n\n        HeatIndicator.prototype = {\n            destroy: function () {\n                var indicator = this;\n\n                if (indicator.graphic) {\n                    indicator.graphic = indicator.graphic.destroy();\n                }\n\n                objectEach(indicator, function (val, key) {\n                    indicator[key] = null;\n                    delete indicator[key];\n                });\n\n                return undefined;\n            },\n            draw: draw,\n            getClassName: function () {\n                return 'highcharts-heat-indicator';\n            },\n            init: function (params) {\n                var indicator = this;\n\n                // Set properties on the indicator.\n                extend(indicator, {\n                    group: params.group,\n                    metrics: params.metrics,\n                    renderer: params.renderer,\n                    xAxis: params.xAxis,\n                    yAxis: params.yAxis\n                });\n\n                indicator.options = merge(defaultOptions, params.options);\n\n                // Return a reference to the indicator.\n                return indicator;\n            },\n            render: function () {\n                var indicator = this,\n                    metrics = indicator.metrics,\n                    xAxis = indicator.xAxis,\n                    yAxis = indicator.yAxis,\n                    options = indicator.options,\n                    start = isNumber(indicator.start) ?\n                        indicator.start : xAxis.min,\n                    end = isNumber(indicator.end) ?\n                        indicator.end : xAxis.max,\n                    x1 = xAxis.translate(start < end ? start : end, 0, 0, 0, 1),\n                    x2 = xAxis.translate(start < end ? end : start, 0, 0, 0, 1),\n                    plotY = yAxis.translate(indicator.y, 0, 1, 0, 1),\n                    y1 = plotY,\n                    y2 = plotY + metrics.width / 2,\n                    animate = {},\n                    attr = {\n                        fill: options.color\n                    };\n\n                // Animate only the width if the graphic is new.\n                if (!indicator.graphic) {\n                    extend(attr, {\n                        x: x1,\n                        y: y1,\n                        width: 0,\n                        height: y2 - y1\n                    });\n                    animate.width = x2 - x1;\n                } else {\n                    extend(animate, {\n                        x: x1,\n                        y: y1,\n                        width: x2 - x1,\n                        height: y2 - y1\n                    });\n                }\n\n                // Draw or destroy the graphic\n                indicator.draw({\n                    animate: animate,\n                    attr: attr,\n                    css: undefined,\n                    group: indicator.group,\n                    renderer: indicator.renderer,\n                    shapeArgs: undefined,\n                    shapeType: 'rect'\n                });\n            },\n            shouldDraw: function () {\n                var indicator = this,\n                    options = indicator.options || {},\n                    filter = options.filter,\n                    start = indicator.start,\n                    end = indicator.end,\n                    y = indicator.y;\n\n                return (\n                    options.enabled === true &&\n                    isNumber(start) &&\n                    isNumber(end) &&\n                    isNumber(y) &&\n                    start < end &&\n                    (isFunction(filter) ? filter(indicator) : true)\n                );\n            },\n            update: function (params) {\n                var indicator = this;\n                extend(indicator, params);\n                this.render();\n            }\n        };\n\n        var calculateSeriesIdleTime = function (series) {\n            var points = series.points\n                    .slice() // Make a copy before sorting.\n                    .sort(function (a, b) {\n                        return b.start - a.start;\n                    }),\n                xAxis = series.xAxis,\n                min = xAxis.min,\n                firstPoint = points[points.length - 1].start,\n                totalIdle = firstPoint > min ? firstPoint - min : 0,\n                max = xAxis.max;\n\n            points.reduce((next, current) => {\n                var start = current.end,\n                    end = next ? next.start : max,\n                    idle = (start < end) ? end - start : 0,\n                    visibleIdle = Math.min(end, max) - Math.max(start, min);\n                visibleIdle = visibleIdle > 0 ? visibleIdle : 0;\n                current.idle = idle;\n                totalIdle += visibleIdle;\n                return current;\n            }, undefined);\n            series.idle = totalIdle;\n        };\n\n        var renderHeatIndicators = function (series) {\n            var options = series.options && series.options.heatIndicator || {};\n\n            // TODO Several modules are dependent upon this, it should be added\n            // as a dependency somehow.\n            calculateSeriesIdleTime(series);\n\n            series.points.forEach(point => {\n                // Get existing indicator from point, or create a new one.\n                var heatIndicator = point.heatIndicator || new HeatIndicator({\n                    group: series.group,\n                    metrics: series.columnMetrics,\n                    xAxis: series.xAxis,\n                    yAxis: series.yAxis,\n                    options: options,\n                    renderer: series.chart.renderer\n                });\n\n                // Update the indicator. Rerenders the graphic with new values.\n                heatIndicator.update({\n                    y: point.y,\n                    start: point.end,\n                    end: point.end + point.idle\n                });\n\n                // Set the resulting indicator on the point.\n                point.heatIndicator = heatIndicator;\n            });\n        };\n\n        return renderHeatIndicators;\n    }(Highcharts, draw));\n\n    var renderEPRIndicators = (function (Highcharts, draw) {\n\n        var objectEach = Highcharts.objectEach,\n            extend = Highcharts.extend,\n            isNumber = Highcharts.isNumber,\n            merge = Highcharts.merge;\n\n        var defaultOptions = {\n            color: 'rgb(255, 0, 0)',\n            lineWidth: 1,\n            dashstyle: 'dash'\n        };\n\n        var EPRIndicator = function (params) {\n            var indicator = this;\n            indicator.init(params);\n            return indicator;\n        };\n\n        EPRIndicator.prototype = {\n            destroy: function () {\n                var indicator = this;\n\n                if (indicator.graphic) {\n                    indicator.graphic = indicator.graphic.destroy();\n                }\n\n                objectEach(indicator, function (val, key) {\n                    indicator[key] = null;\n                    delete indicator[key];\n                });\n\n                return undefined;\n            },\n            draw: draw,\n            getClassName: function () {\n                return 'highcharts-eap-indicator';\n            },\n            init: function (params) {\n                var indicator = this;\n\n                // Set properties on the indicator.\n                extend(indicator, {\n                    group: params.group,\n                    metrics: params.metrics,\n                    renderer: params.renderer,\n                    xAxis: params.xAxis,\n                    yAxis: params.yAxis\n                });\n\n                indicator.options = merge(defaultOptions, params.options);\n\n                // Return a reference to the indicator.\n                return indicator;\n            },\n            render: function () {\n                var indicator = this,\n                    renderer = indicator.renderer,\n                    metrics = indicator.metrics,\n                    options = indicator.options,\n                    lineWidth = options.lineWidth,\n                    plotX = indicator.xAxis.translate(indicator.x, 0, 0, 0, 1),\n                    plotY = indicator.yAxis.translate(indicator.y, 0, 1, 0, 1),\n                    x1 = plotX,\n                    x2 = plotX,\n                    y1 = plotY - metrics.width / 2,\n                    y2 = plotY + metrics.width / 2,\n                    path = renderer.crispLine(\n                        [['M', x1, y1], ['L', x2, y2]], lineWidth\n                    ),\n                    attr = {\n                        stroke: options.color,\n                        'stroke-width': lineWidth,\n                        dashstyle: options.dashstyle\n                    },\n                    animate = {};\n\n                // Animate if the graphic is not new.\n                if (!indicator.graphic) {\n                    attr.d = path;\n                } else {\n                    animate.d = path;\n                }\n\n                // Draw or destroy the graphic\n                indicator.draw({\n                    animate: animate,\n                    attr: attr,\n                    css: undefined,\n                    group: indicator.group,\n                    renderer: indicator.renderer,\n                    shapeArgs: undefined,\n                    shapeType: 'path'\n                });\n            },\n            shouldDraw: function () {\n                var indicator = this,\n                    x = indicator.x,\n                    y = indicator.y;\n\n                return (\n                    indicator.enabled === true && isNumber(x) && isNumber(y)\n                );\n            },\n            update: function (params) {\n                var indicator = this;\n                extend(indicator, params);\n                this.render();\n            }\n        };\n\n        var renderEPRIndicators = function (series) {\n            series.points.forEach(point => {\n                var options = point.options && point.options.indicator || {},\n                    // point.options.indicator is copied to point.indicator, so\n                    // we use point.indicatorObj instead.\n                    indicator = point.indicatorObj || new EPRIndicator({\n                        group: series.group,\n                        metrics: series.columnMetrics,\n                        xAxis: series.xAxis,\n                        yAxis: series.yAxis,\n                        renderer: series.chart.renderer\n                    });\n                indicator.update({\n                    enabled: options.enabled,\n                    x: options.x ? point.start + options.x : point.start,\n                    y: point.y\n                });\n\n                point.indicatorObj = indicator;\n            });\n        };\n\n        return renderEPRIndicators;\n    }(Highcharts, draw));\n\n    (function (Highcharts, renderHeatIndicators, renderEPRIndicators) {\n        var Series = Highcharts.Series;\n        // Add heat indicator functionality to Highcharts Series.\n        Highcharts.addEvent(Series, 'afterRender', function () {\n            var series = this;\n            renderEPRIndicators(series);\n            renderHeatIndicators(series);\n        });\n    }(Highcharts, renderHeatIndicators, renderEPRIndicators));\n\n}(Highcharts));\n\n/**\n * --- Logistics module end\n */\n\n/**\n * Variables\n */\nvar today = +Date.now(),\n    minutes = 60 * 1000,\n    hours = 60 * minutes,\n    days = 24 * hours,\n    dateFormat = function (date) {\n        var format = '%e. %b';\n        return Highcharts.dateFormat(format, date);\n    },\n    find = Highcharts.find,\n    xAxisMin = today - (10 * days),\n    xAxisMax = xAxisMin + 90 * days,\n    data;\n\n/**\n * The data used in this visualization.\n */\ndata = {\n    // The different events in a lap of a journey.\n    events: {\n        loading: {\n            color: '#395627',\n            tooltipFormatter: function (point) {\n                return [\n                    '<b>Loading</b><br/>',\n                    'Start: ' + dateFormat(point.start) + '<br/>',\n                    'End: ' + dateFormat(point.end) + '<br/>'\n                ].join('');\n            }\n        },\n        voyage: {\n            color: '#558139',\n            tooltipFormatter: function (point) {\n                var indicator = point.indicator;\n                return [\n                    '<b>Voyage</b><br/>',\n                    'Start: (' + point.startLocation + ') ' +\n                        dateFormat(point.start) + '<br/>',\n                    'End: (' + point.endLocation + ') ' +\n                        dateFormat(point.end) + '<br/>',\n                    indicator ? 'EPR: ' + dateFormat(indicator.x) : ''\n                ].join('');\n            }\n        },\n        unloading: {\n            color: '#aad091',\n            tooltipFormatter: function (point) {\n                return [\n                    '<b>Unloading</b><br/>',\n                    'Start: ' + dateFormat(point.start) + '<br/>',\n                    'End: ' + dateFormat(point.end) + '<br/>'\n                ].join('');\n            }\n        }\n    },\n    // All the vessels and its sceduled journeys\n    vessels: [{\n        name: 'Vessel 1',\n        journeys: [{\n            name: 'Contract 1',\n            start: today + days,\n            laps: [{\n                duration: 21 * days,\n                startLocation: 'USGLS',\n                endLocation: 'BEZEE',\n                loadDuration: 1 * days + 2 * hours + 45 * minutes,\n                unloadDuration: 1 * days + 2 * hours + 45 * minutes\n            }, {\n                duration: 11 * days,\n                startLocation: 'BEZEE',\n                endLocation: 'USCP6',\n                loadDuration: 0,\n                unloadDuration: 0,\n                color: '#c6dfb6'\n            }]\n        }, {\n            name: 'Contract 5',\n            start: today + 50 * days,\n            laps: [{\n                duration: 7 * days,\n                startLocation: 'USGLS',\n                endLocation: 'BEZEE',\n                loadDuration: 2 * days + 2 * hours + 45 * minutes,\n                unloadDuration: 1 * days + 2 * hours + 45 * minutes\n            }, {\n                duration: 7 * days,\n                startLocation: 'BEZEE',\n                endLocation: 'USCP6',\n                loadDuration: 0,\n                unloadDuration: 1 * days + 4 * hours,\n                color: '#c6dfb6'\n            }, {\n                duration: 19 * days,\n                startLocation: 'USCP6',\n                endLocation: 'NOVIS',\n                loadDuration: 0,\n                unloadDuration: 0\n            }]\n        }]\n    }, {\n        name: 'Vessel 2',\n        journeys: [{\n            name: 'Contract 2',\n            start: today - 5 * days,\n            laps: [{\n                duration: 13 * days,\n                startLocation: 'USGLS',\n                endLocation: 'BEZEE',\n                loadDuration: 2 * days + 2 * hours + 45 * minutes,\n                unloadDuration: 2 * days + 2 * hours + 45 * minutes\n            }, {\n                duration: 8 * days,\n                startLocation: 'BEZEE',\n                endLocation: 'USCP6',\n                loadDuration: 0,\n                unloadDuration: 0,\n                color: '#c6dfb6'\n            }],\n            earliestPossibleReturn: (today - 5 * days) + 20 * days\n        }, {\n            name: 'Contract 3',\n            start: today + 23 * days,\n            laps: [{\n                duration: 5 * days,\n                startLocation: 'USGLS',\n                endLocation: 'BEZEE',\n                loadDuration: 2 * days + 2 * hours + 45 * minutes,\n                unloadDuration: 2 * days + 2 * hours + 45 * minutes\n            }, {\n                duration: 14 * days,\n                startLocation: 'BEZEE',\n                endLocation: 'USCP6',\n                loadDuration: 0,\n                unloadDuration: 0,\n                color: '#c6dfb6'\n            }]\n        }, {\n            name: 'Contract 4',\n            start: today + 60 * days,\n            laps: [{\n                duration: 11 * days,\n                startLocation: 'USGLS',\n                endLocation: 'BEZEE',\n                loadDuration: 2 * days + 2 * hours + 45 * minutes,\n                unloadDuration: 2 * days + 2 * hours + 45 * minutes\n            }, {\n                duration: 6 * days,\n                startLocation: 'BEZEE',\n                endLocation: 'USCP6',\n                loadDuration: 0,\n                unloadDuration: 0,\n                color: '#c6dfb6'\n            }]\n        }]\n    }]\n};\n\n/**\n * Creates a point in a lap.\n */\nvar getPoint = function (params) {\n    var start = params.start,\n        tripName = params.tripName,\n        type = params.type,\n        vessel = params.vessel,\n        duration = params.duration,\n        voyage = params.voyage,\n        indicator,\n        earliestPossibleReturn = params.epr,\n        end = start + duration;\n\n    indicator = (\n        (\n            Highcharts.isNumber(earliestPossibleReturn) &&\n            start < earliestPossibleReturn &&\n            earliestPossibleReturn < end\n        ) ?\n            {\n                enabled: true,\n                x: earliestPossibleReturn - start\n            } :\n            undefined\n    );\n\n    return {\n        start: start,\n        end: end,\n        color: voyage && voyage.color || data.events[type].color,\n        vessel: vessel.name,\n        indicator: indicator,\n        y: params.y,\n        type: type,\n        startLocation: voyage && voyage.startLocation,\n        endLocation: voyage && voyage.endLocation,\n        name: tripName,\n        trip: tripName,\n        dragDrop: {\n            draggableStart: type === 'voyage',\n            draggableEnd: type === 'voyage'\n        }\n    };\n};\n\n/**\n * Creates a set of points based on a lap. These points are grouped together.\n */\nvar getGroupFromTrip = function (trip, vessel, y) {\n    return trip.laps.reduce(function (group, voyage) {\n        var points = [];\n\n        if (voyage.loadDuration) {\n            points.push(getPoint({\n                start: group.end,\n                duration: voyage.loadDuration,\n                tripName: trip.name,\n                type: 'loading',\n                vessel: vessel,\n                y: y\n            }));\n            group.end += voyage.loadDuration;\n        }\n\n        points.push(getPoint({\n            start: group.end,\n            duration: voyage.duration,\n            voyage: voyage,\n            epr: trip.earliestPossibleReturn,\n            tripName: trip.name,\n            type: 'voyage',\n            vessel: vessel,\n            y: y\n        }));\n        group.end += voyage.duration;\n\n        if (voyage.unloadDuration) {\n            points.push(getPoint({\n                start: group.end,\n                duration: voyage.unloadDuration,\n                tripName: trip.name,\n                type: 'unloading',\n                vessel: vessel,\n                y: y\n            }));\n            group.end += voyage.unloadDuration;\n        }\n\n        // Add the points\n        group.points = group.points.concat(points);\n        return group;\n    }, {\n        end: trip.start, // Previous point end\n        points: []\n    });\n};\n\n/**\n * Parses the data and creates all the series of the chart.\n */\nvar getSeriesFromInformation = function (info) {\n    var vessels = info.vessels;\n    return vessels.map(function (vessel, i) {\n        var data = vessel.journeys.reduce(function (result, trip) {\n            var group = getGroupFromTrip(trip, vessel, i);\n            return result.concat(group.points);\n        }, []);\n\n        // One series per vessel\n        return {\n            name: vessel.name,\n            data: data,\n            id: i\n        };\n    });\n};\n\n/**\n * Modify event to handle modifying other points in group when resizing\n */\nvar customResize = function (e, chart) {\n    var newPoints = e.newPoints,\n        defined = Highcharts.defined,\n        objectEach = Highcharts.objectEach,\n        start,\n        end,\n        diff,\n        resizePoint;\n\n    if (e.newPoint && defined(e.newPoint.start) !== defined(e.newPoint.end)) {\n        start = e.newPoint.start;\n        end = e.newPoint.end;\n        resizePoint = chart.get(e.newPointId);\n\n        diff = defined(start) && start - resizePoint.options.start ||\n                defined(end) && end - resizePoint.options.end;\n\n        objectEach(e.origin.points, function (pointOrigin) {\n            var point = pointOrigin.point;\n            if (\n                point.id !== e.newPointId && (\n                    defined(start) && point.end <= resizePoint.options.start ||\n                    defined(end) && point.start >= resizePoint.options.end\n                )\n            ) {\n                newPoints[point.id] = {\n                    point: point,\n                    newValues: {\n                        start: point.start + diff,\n                        end: point.end + diff\n                    }\n                };\n            }\n        });\n    }\n};\n\n/**\n * Check if new points collide with existing ones\n */\nvar newPointsColliding = function (newPoints, chart) {\n    var pick = Highcharts.pick,\n        inArray = Highcharts.inArray,\n        groupedPoints = chart.dragDropData && chart.dragDropData.groupedPoints,\n        y,\n        minX = Object.keys(newPoints).reduce((acc, id) => {\n            y = pick(newPoints[id].newValues.y, newPoints[id].point.y);\n            return Math.min(\n                acc, pick(\n                    newPoints[id].newValues.start, newPoints[id].point.start\n                )\n            );\n        }, Infinity),\n        maxX = Object.keys(newPoints).reduce(function (acc, id) {\n            return Math.max(\n                acc, pick(newPoints[id].newValues.end, newPoints[id].point.end)\n            );\n        }, -Infinity),\n        newSeries = chart.get(y),\n        i,\n        collidePoint,\n        pointOverlaps = function (point) {\n            return point.end >= minX && point.start <= minX ||\n                point.start <= maxX && point.end >= maxX ||\n                point.start <= minX && point.end >= maxX ||\n                point.start >= minX && point.end <= maxX;\n        };\n\n    if (newSeries) {\n        i = newSeries.points ? newSeries.points.length : 0;\n        while (i--) {\n            collidePoint = newSeries.points[i];\n            if (\n                inArray(collidePoint, groupedPoints) < 0 &&\n                pointOverlaps(collidePoint)\n            ) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n/**\n * Add collision detection on move/resize\n */\nvar customDrag = function (e) {\n    var series = this.series,\n        chart = series.chart;\n\n    // Handle the resize\n    customResize(e, chart);\n\n    // Check collision\n    if (newPointsColliding(e.newPoints, chart)) {\n        chart.dragDropData.isColliding = true;\n        chart.setGuideBoxState('collide', series.options.dragDrop.guideBox);\n    } else if (chart.dragDropData) {\n        delete chart.dragDropData.isColliding;\n        chart.setGuideBoxState('default', series.options.dragDrop.guideBox);\n    }\n};\n\n/**\n * Implement custom drop. Do normal update, but move points between series when\n * changing their y value.\n */\nvar customDrop = function (e) {\n    var newPoints = e.newPoints,\n        chart = this.series.chart,\n        defined = Highcharts.defined,\n        objectEach = Highcharts.objectEach;\n\n    // Just return if we are colliding.\n    if (chart.dragDropData.isColliding) {\n        return false;\n    }\n\n    // Stop further dragdrops while we update\n    chart.isDragDropAnimating = true;\n\n    // Update the points\n    objectEach(newPoints, function (update) {\n        var newValues = update.newValues,\n            oldPoint = update.point,\n            newSeries = defined(newValues.y) ?\n                chart.get(newValues.y) : oldPoint.series;\n\n        // Destroy any old heat indicator objects\n        if (oldPoint.heatIndicator) {\n            oldPoint.heatIndicator =\n                oldPoint.heatIndicator.destroy();\n        }\n        if (oldPoint.indicatorObj) {\n            oldPoint.indicatorObj =\n                oldPoint.indicatorObj.destroy();\n        }\n\n        // Update the point\n        if (newSeries !== oldPoint.series) {\n            newValues = Highcharts.merge(\n                oldPoint.options, newValues\n            );\n            update.point = oldPoint = oldPoint.remove(false);\n            newSeries.addPoint(newValues, false);\n        } else {\n            oldPoint.update(newValues, false);\n        }\n    });\n\n    // Redraw with specific animation\n    chart.redraw({\n        duration: 400\n    });\n    setTimeout(function () {\n        delete chart.isDragDropAnimating;\n        if (chart.hoverPoint && !chart.dragHandles) {\n            chart.hoverPoint.showDragHandles();\n        }\n    }, 400);\n\n    // Don't do the default drop\n    return false;\n};\n\n/**\n * Custom formatter for data labels which are left aligned.\n */\nvar leftLabelFormatter = function () {\n    if (this.point.type === 'voyage') {\n        return this.point.startLocation;\n    }\n};\n\n/**\n * Custom formatter for data labels which are center aligned.\n */\nvar centerLabelFormatter = function () {\n    if (this.point.type === 'voyage') {\n        return ' ' + this.point.name + ' ';\n    }\n};\n\n/**\n * Custom formatter for data labels which are right aligned.\n */\nvar rightLabelFormatter = function () {\n    if (this.point.type === 'voyage') {\n        return this.point.endLocation;\n    }\n};\n\n/**\n * Custom formatter for axis labels displaying the series name.\n */\nvar gridColumnFormatterSeriesName = function () {\n    var chart = this.chart,\n        series = chart.get(this.value);\n    return series.name;\n};\n\n/**\n * Creates a category label and formats it based on the value.\n */\nvar getCategoryFromIdleTime = function (utilized, idle) {\n    var thresholds = {\n            25: 'bad',\n            50: 'ok',\n            75: 'good',\n            100: 'great'\n        },\n        threshold = find(Object.keys(thresholds), function (threshold) {\n            return utilized < +threshold;\n        }),\n        className = thresholds[threshold];\n    return [\n        '<span class=\"info-span ' + className + '\">',\n        '    <span class=\"utilized\">' + utilized + '%</span><br/>',\n        '    <span>t: ' + idle + ' days</span>',\n        '</span>'\n    ].join('\\n');\n};\n\n/**\n * Custom formatter for axis labels displaying the vessels number of idle days,\n * and its percentage of utilized time.\n */\nvar gridColumnFormatterSeriesIdle = function () {\n    var chart = this.chart,\n        series = chart.get(this.value),\n        xAxis = series.xAxis,\n        total = xAxis.max - xAxis.min,\n        idle = series.idle || 0,\n        used = total - idle,\n        percentage = Math.round((100 / total) * used),\n        idleDays = Math.round(idle / days);\n    return getCategoryFromIdleTime(percentage, idleDays);\n};\n\n/**\n * Custom formatter for the tooltip.\n */\nvar tooltipFormatter = function () {\n    var point = this.point,\n        trip = point.trip,\n        series = point.series,\n        formatter = data.events[point.type].tooltipFormatter;\n    return '<b>' + trip + ' - ' + series.name + '</b><br/>' + formatter(point);\n};\n\n/**\n * Set the options and create the gantt chart.\n */\nHighcharts.ganttChart('container', {\n    plotOptions: {\n        series: {\n            dragDrop: {\n                draggableX: true,\n                draggableY: true,\n                dragMinY: 0,\n                dragMaxY: data.vessels.length - 1,\n                liveRedraw: false,\n                groupBy: 'trip',\n                guideBox: {\n                    collide: {\n                        color: 'rgba(200, 0, 0, 0.4)'\n                    }\n                }\n            },\n            heatIndicator: {\n                enabled: true,\n                filter: function (indicator) {\n                    var start = indicator.start,\n                        end = indicator.end,\n                        idleTime = end - start;\n                    return idleTime > (10 * days);\n                }\n            },\n            stickyTracking: true,\n            cursor: 'move',\n            borderRadius: 0,\n            borderWidth: 0,\n            pointPadding: 0,\n            dataLabels: [{\n                enabled: true,\n                labelrank: 1,\n                formatter: leftLabelFormatter,\n                align: 'left',\n                style: {\n                    fontSize: '8px'\n                }\n            }, {\n                enabled: true,\n                labelrank: 2,\n                formatter: centerLabelFormatter,\n                align: 'center',\n                borderWidth: 1,\n                padding: 3,\n                style: {\n                    fontSize: '10px'\n                }\n            }, {\n                enabled: true,\n                labelrank: 1,\n                formatter: rightLabelFormatter,\n                align: 'right',\n                style: {\n                    fontSize: '8px'\n                }\n            }],\n            point: {\n                events: {\n                    drag: customDrag,\n                    drop: customDrop\n                }\n            }\n        }\n    },\n    legend: {\n        enabled: false\n    },\n    rangeSelector: {\n        enabled: true,\n        selected: 1\n    },\n    scrollbar: {\n        enabled: true\n    },\n    series: getSeriesFromInformation(data),\n    tooltip: {\n        formatter: tooltipFormatter\n    },\n    xAxis: [{\n        type: 'datetime',\n        currentDateIndicator: true,\n        grid: false,\n        labels: {\n            format: undefined\n        },\n        min: xAxisMin,\n        max: xAxisMax,\n        tickInterval: undefined\n    }],\n    yAxis: [{\n        type: 'category',\n        reversed: true,\n        maxPadding: 0,\n        staticScale: 100,\n        labels: {\n            useHTML: true\n        },\n        grid: {\n            enabled: true,\n            columns: [{\n                labels: {\n                    formatter: gridColumnFormatterSeriesName\n                }\n            }, {\n                labels: {\n                    formatter: gridColumnFormatterSeriesIdle\n                }\n            }]\n        }\n    }]\n});","css":".clearfix {\n    clear: both;\n}\n\n.info-span .utilized {\n    font-size: 14px;\n}\n\n.info-span.great {\n    color: #788c6b;\n}\n\n.info-span.good {\n    color: #fbe496;\n}\n\n.info-span.ok {\n    color: #e0b08b;\n}\n\n.info-span.bad {\n    color: #c79495;\n}\n\n#description {\n    max-width: 800px;\n    margin: 0 auto;\n}\n","html":"\n<div id=\"container\"></div>\n\n<p id=\"description\">\n    An advanced example of how to use a gantt chart to plan and visualize \n    resources in logistics, in this case shipping. \n    The chart displays a set of vessels and its scheduled journeys. \n    The journeys can consist of one or more laps, which in itself contains \n    loading, voyage, and unloading, these can be moved or resized. \n    The chart also includes custom indicators like the Heat Indicator which \n    displays when the vessels idle time goes above a threshold, and the \n    Earliest Possible Return Indicator which displays when the vessel can \n    return if it travels by maximum speed.\n</p>\n","npm":"// 安装\nnpm install highcharts@11.0.1 --save\n\n// import 模块 \nimport Highcharts      from 'highcharts/highcharts-gantt';\nimport Stock           from 'highcharts/modules/stock';\nimport DraggablePoints from 'highcharts/modules/draggable-points';\n\n// 初始化模块\nStock(Highcharts);\nDraggablePoints(Highcharts);\n","scripts":["https://code.highcharts.com/gantt/11.0.1/highcharts-gantt.js","https://code.highcharts.com/stock/11.0.1/modules/stock.js","https://code.highcharts.com/gantt/11.0.1/modules/draggable-points.js"]}