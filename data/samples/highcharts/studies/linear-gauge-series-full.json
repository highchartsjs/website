{"js":"/**\n * (c) 2010-2017 Paweł Dalek\n *\n * License: www.highcharts.com/license\n */\n\n'use strict';\n// import H from '../Core/Globals.js';\n// import '../Core/Utilities.js';\nvar H = Highcharts;\n\nvar pick = H.pick,\n    isNumber = H.isNumber,\n    addEvent = H.addEvent,\n    seriesType = H.seriesType,\n    seriesTypes = H.seriesTypes,\n    relativeLength = H.relativeLength,\n    columnProto = H.seriesTypes.column.prototype;\n\nH.SVGRenderer.prototype.symbols.target = function (\n    x, y, w, h, bh, i, inverted\n) {\n    return inverted ? [\n        ['M', x, y],\n        ['L', -w / 2, -h + bh],\n        ['L', -w / 2, -h],\n        ['L', x, -h + i],\n        ['L', w / 2, -h],\n        ['L', w / 2, -h + bh],\n        ['Z']\n    ] : [\n        ['M', x, y],\n        ['L', -h + bh, w / 2],\n        ['L', -h, w / 2],\n        ['L', -h + i, y],\n        ['L', -h, -w / 2],\n        ['L', -h + bh, -w / 2],\n        ['Z']\n    ];\n};\n\n/**\n * The lineargauge series type.\n *\n * @class seriesTypes.lineargauge\n * @augments seriesTypes.column\n */\nseriesType('lineargauge', 'column',\n    /**\n     * A lineargauge graph is used for visualizing data on linear scale\n     * within the specific range. It uses special pointers (targets).\n     * Mentioned range can be defined by setting\n     * [plotBands](#yAxis.plotBands) on [yAxis](#yAxis).\n     *\n     * @extends plotOptions.column\n     * @product highcharts\n     * @sample {highcharts} highcharts/demo/lineargauge/ Linearguage graph\n     * @since 6.0.0\n     * @excluding animationLimit,boostThreshold,edgeColor,edgeWidth,\n     *            findNearestPointBy,getExtremesFromAll\n     * @optionparent plotOptions.lineargauge\n     */\n    {\n        /**\n         * Display target on a point or alongside the `yAxis`.\n         *\n         * @type {Boolean}\n         * @since 6.0.0\n         * @default true\n         * @product highcharts\n         */\n        onPoint: true,\n\n        /**\n         * Whether to display or hide additional columns along with targets.\n         *\n         * @type {Boolean}\n         * @since 6.0.0\n         * @default false\n         * @product highcharts\n         */\n        showColumn: false,\n\n        /**\n         * Show additional line coming out of the target.\n         *\n         * @type {Boolean}\n         * @since 6.0.0\n         * @default false\n         * @product highcharts\n         */\n        showLine: false,\n\n        /**\n         * All options related with look and positiong of targets.\n         *\n         * @type {Object}\n         * @since 6.0.0\n         * @product highcharts\n         */\n        targetOptions: {\n            /**\n             * The length of the base part of the target (similar to [dial.baseLength](#plotOptions.gauge.dial.baseLength)).\n             * Can be pixel value or percentage value based on [length](#plotOptions.lineargauge.targetOptions.length).\n             *\n             * @type {Number|String}\n             * @since 6.0.0\n             * @default '50%'\n             * @product highcharts\n             */\n            baseLength: '50%',\n\n            /* = if (build.classic) { =*/\n            /**\n             * The border color of the symbol representing the target. When\n             * not set, point's border color is used.\n             *\n             * In styled mode, target border color can be set with the `.highcharts-lineargauge-target-symbol` class.\n             *\n             * @type {Color}\n             * @since 6.0.0\n             * @product highcharts\n             * @apioption plotOptions.lineargauge.targetOptions.borderColor\n             */\n\n            /**\n             * The border width of the symbol representing the target. When\n             * not set, point's border width is used.\n             *\n             * In styled mode, target border color can be set with the `.highcharts-lineargauge-target-symbol` class.\n             *\n             * @type {Number}\n             * @since 6.0.0\n             * @product highcharts\n             * @apioption plotOptions.lineargauge.targetOptions.borderWidth\n             */\n\n            /**\n             * The color of the symbol representing the target. When\n             * not set, point's color is used.\n             *\n             * In styled mode, target color can be set with the `.highcharts-lineargauge-target-symbol` class.\n             *\n             * @type {Color}\n             * @since 6.0.0\n             * @product highcharts\n             * @apioption plotOptions.lineargauge.targetOptions.color\n             */\n            /* = } =*/\n\n            /**\n             * The indentation on the upper part of the target symbol.\n             *\n             * Can be pixel value or percentage value based on [length](#plotOptions.lineargauge.targetOptions.length).\n             *\n             * @type {Number|String}\n             * @since 6.0.0\n             * @default '20%'\n             * @product highcharts\n             */\n            indent: '20%',\n\n            /* = if (build.classic) { =*/\n            /**\n             * The color of the additional target line. When\n             * not set, point's border color is used.\n             *\n             * In styled mode, target color can be set with the `.highcharts-lineargauge-target-line` class.\n             *\n             * @type {Color}\n             * @since 6.0.0\n             * @product highcharts\n             * @apioption plotOptions.lineargauge.targetOptions.lineColor\n             */\n\n            /**\n             * The width of the additional target line. When\n             * not set, point's border width is used.\n             *\n             * In styled mode, target border color can be set with the `.highcharts-lineargauge-target-line` class.\n             *\n             * @type {Number}\n             * @since 6.0.0\n             * @product highcharts\n             * @apioption plotOptions.lineargauge.targetOptions.lineWidth\n             */\n            /* = } =*/\n\n            /**\n             * The zIndex of the target line.\n             *\n             * @type {Number}\n             * @since 6.0.0\n             * @default 1\n             * @product highcharts\n             */\n            lineZIndex: 1,\n\n            /**\n             * The total length of the target.\n             * Can be pixel value or percentage value based on column point's width.\n             *\n             * @type {Number|String}\n             * @since 6.0.0\n             * @default '50%'\n             * @product highcharts\n             */\n            length: '50%',\n\n            /**\n             * The width of the target.\n             * Can be pixel value or percentage value based on column point's width.\n             *\n             * @type {Number|String}\n             * @since 6.0.0\n             * @default '50%'\n             * @product highcharts\n             */\n            width: '50%',\n\n            /**\n             * The zIndex of the target symbol.\n             *\n             * @type {Number}\n             * @since 6.0.0\n             * @default 3\n             * @product highcharts\n             */\n            zIndex: 3\n        }\n    }, {\n        /**\n         * Function responsible for creating or updating target symbol and target line.\n         */\n        createUpdateGraphic: function (\n            graphic, path, xPosition, yPosition, beginningAtrr, endAttr\n        ) {\n            var series = this,\n                chart = series.chart,\n                seriesOptions = series.options,\n                updateGraphic = chart.pointCount < (\n                    seriesOptions.animationLimit || 250\n                ) ? 'animate' : 'attr';\n\n            if (graphic) {\n                graphic[updateGraphic]({\n                    d: path,\n                    translateX: xPosition,\n                    translateY: yPosition\n                });\n            } else {\n                graphic = chart.renderer.path(path)\n                    .attr(beginningAtrr)\n                    .add();\n\n                graphic[updateGraphic](\n                    endAttr,\n                    pick(seriesOptions.animation, { duration: 1000 })\n                );\n            }\n\n            return graphic;\n        },\n        /**\n         * The target symbol and line is created for each point and added to it. Inverting\n         * chart and reversing axes are taken into account in calculating their position on chart.\n         * This method is based on column series drawPoints function.\n         */\n        drawPoints: function () {\n            var series = this,\n                points = series.points,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                xAxisLength = xAxis.len,\n                yAxisLength = yAxis.len,\n                yAxisReversed = yAxis.reversed,\n                chart = series.chart,\n                plotTop = chart.plotTop,\n                plotLeft = chart.plotLeft,\n                tooltip = chart.tooltip,\n                renderer = chart.renderer,\n                inverted = chart.inverted,\n                seriesOptions = series.options,\n                minPointLength = seriesOptions.minPointLength,\n                seriesTargetOptions = seriesOptions.targetOptions,\n                shape = seriesTypes[series.type].prototype.pointClass.prototype\n                    .shape;\n\n            columnProto.drawPoints.apply(series);\n\n            points.forEach(function (point) {\n                var targetSymGraphic = point.targetSymGraphic,\n                    targetLinGraphic = point.targetLinGraphic,\n                    pointOptions = point.options,\n                    pointTargetOptions = pointOptions.targetOptions || {},\n                    dataLabel = point.dataLabel,\n                    valueX = point.x,\n                    valueY = point.y,\n                    target = point.target,\n                    targetEvents = [],\n                    halfPointWidth,\n                    dataLabelBox,\n                    columnStart,\n                    pPlotY,\n                    barX,\n                    onPoint,\n                    showColumn,\n                    showLine,\n                    baseLength,\n                    length,\n                    width,\n                    indent,\n                    symbolPath,\n                    linePath,\n                    borderWidth,\n                    lineWidth,\n                    lineZIndex,\n                    zIndex,\n                    shapeArgs,\n                    shapeArgsWidth,\n                    beginningAtrr,\n                    offsetOnPoint,\n                    xAttr,\n                    yAttr,\n                    xPosition,\n                    yPosition,\n                    pixelX,\n                    pixelY;\n\n                if (isNumber(valueY) && valueY !== null) {\n                    halfPointWidth = point.pointWidth / 2;\n                    pPlotY = point.plotY;\n                    barX = point.barX;\n\n                    pixelX = inverted ?\n                        xAxisLength - barX - halfPointWidth + plotTop :\n                        barX + halfPointWidth + plotLeft;\n                    pixelY = target ?\n                        yAxis.toPixels(target, false) :\n                        yAxis.toPixels(valueY, false);\n\n                    if (inverted) {\n                        // Considering minPointLength when chart is inverted\n                        if (minPointLength) {\n                            if (!yAxisReversed) {\n                                if (pixelY < (minPointLength + plotLeft)) {\n                                    pixelY = minPointLength + plotLeft;\n                                }\n                            } else {\n                                if (pPlotY < minPointLength) {\n                                    pixelY = yAxisLength - minPointLength +\n                                        plotLeft;\n                                }\n                            }\n                        }\n                    } else {\n                        // Considering minPointLength when chart is not inverted\n                        if (minPointLength) {\n                            if (!yAxisReversed) {\n                                if (\n                                    (yAxisLength - pixelY) < (\n                                        minPointLength - plotTop\n                                    )\n                                ) {\n                                    pixelY = yAxisLength - minPointLength +\n                                        plotTop;\n                                }\n                            } else {\n                                if (pPlotY < minPointLength) {\n                                    pixelY = minPointLength + plotTop;\n                                }\n                            }\n                        }\n                    }\n\n                    shapeArgs = point.shapeArgs;\n                    shapeArgsWidth = shapeArgs.width;\n\n                    // The option which controls whether target should display on series or on axis\n                    onPoint = pick(pointOptions.onPoint, seriesOptions.onPoint);\n\n                    // Show/hide additional column\n                    showColumn = pick(\n                        pointOptions.showColumn,\n                        seriesOptions.showColumn\n                    );\n\n                    // The option which controls whether target should have an additional line\n                    showLine = pick(\n                        pointOptions.showLine,\n                        seriesOptions.showLine\n                    );\n\n                    // Total length of a target\n                    length = relativeLength(\n                        pick(\n                            pointTargetOptions.length,\n                            seriesTargetOptions.length\n                        ),\n                        shapeArgsWidth\n                    );\n\n                    // Total width of a target\n                    width = relativeLength(\n                        pick(\n                            pointTargetOptions.width,\n                            seriesTargetOptions.width\n                        ),\n                        shapeArgsWidth\n                    );\n\n                    // Border width of a target\n                    borderWidth = pick(\n                        pointTargetOptions.borderWidth,\n                        seriesTargetOptions.borderWidth\n                    );\n\n                    // The zIndex of a target symbol\n                    zIndex = pick(\n                        pointTargetOptions.zIndex,\n                        seriesTargetOptions.zIndex\n                    );\n\n                    // Width of a target line\n                    lineWidth = pick(\n                        pointTargetOptions.lineWidth,\n                        seriesTargetOptions.lineWidth,\n                        seriesOptions.borderWidth,\n                        point.borderWidth,\n                        1\n                    );\n\n                    // The zIndex of a target line\n                    lineZIndex = pick(\n                        pointTargetOptions.lineZIndex,\n                        seriesTargetOptions.lineZIndex\n                    );\n\n                    // Shape for lineargauge series\n                    if (shape === 'target') {\n                        // Base length of a target\n                        baseLength = relativeLength(\n                            pick(\n                                pointTargetOptions.baseLength,\n                                seriesTargetOptions.baseLength\n                            ),\n                            length\n                        );\n\n                        // Vertical indent of a target\n                        indent = relativeLength(\n                            pick(\n                                pointTargetOptions.indent,\n                                seriesTargetOptions.indent\n                            ),\n                            length\n                        );\n\n                        symbolPath = renderer.symbols[shape](\n                            0,\n                            0,\n                            width,\n                            length,\n                            baseLength,\n                            indent,\n                            inverted\n                        );\n                        symbolPath = renderer.crispLine(\n                            symbolPath,\n                            borderWidth || 1\n                        );\n                    } else if (shape === 'rectangle') { // Shape for bullet series\n                        onPoint = true;\n                        showLine = false;\n                        showColumn = true;\n\n                        symbolPath = renderer\n                            .symbols[shape](0, 0, width, length, inverted);\n                    }\n\n                    if (inverted) {\n                        xPosition = pixelY;\n                        yPosition = onPoint ? pixelX : xAxis.top;\n                    } else {\n                        xPosition = onPoint ? pixelX : xAxis.left;\n                        yPosition = pixelY;\n                    }\n                    columnStart = yAxis\n                        .toPixels(series.options.threshold, false);\n\n                    xAttr = {\n                        translateX: xPosition\n                    };\n\n                    yAttr = {\n                        translateY: yPosition\n                    };\n\n                    // The beginning coordinates\n                    beginningAtrr = {\n                        translateX: inverted ? columnStart : xPosition,\n                        translateY: inverted ? yPosition : columnStart\n                    };\n\n                    beginningAtrr.zIndex = zIndex;\n\n                    // Creating/updating target symbol\n                    point.targetSymGraphic = targetSymGraphic = series\n                        .createUpdateGraphic(\n                            targetSymGraphic,\n                            symbolPath,\n                            xPosition,\n                            yPosition,\n                            beginningAtrr,\n                            (inverted ? xAttr : yAttr)\n                        );\n\n                    if (showLine) {\n                        offsetOnPoint = xAxisLength -\n                            (\n                                onPoint ?\n                                    pixelX - (inverted ? plotTop : plotLeft) :\n                                    0\n                            );\n\n                        linePath = inverted ? [\n                            ['M', 0, 0],\n                            ['L', 0, offsetOnPoint]\n                        ] : [\n                            ['M', 0, 0],\n                            ['L', offsetOnPoint, 0]\n                        ];\n                        // linePath = renderer.crispLine(linePath, lineWidth || 1);\n\n                        beginningAtrr.zIndex = lineZIndex;\n\n                        // Creating/updating target line\n                        point.targetLinGraphic = targetLinGraphic = series\n                            .createUpdateGraphic(\n                                targetLinGraphic,\n                                linePath,\n                                xPosition,\n                                yPosition,\n                                beginningAtrr,\n                                (inverted ? xAttr : yAttr)\n                            );\n                    }\n\n                    if (!showColumn) {\n                        point.graphic.hide();\n\n                        if (!onPoint && dataLabel) {\n                            dataLabelBox = dataLabel.getBBox();\n\n                            dataLabel.attr(inverted ? {\n                                x: yAxis.toPixels(valueY, true) -\n                                    dataLabelBox.width / 2,\n                                y: 0\n                            } : {\n                                x: 0,\n                                y: yAxis.toPixels(valueY, true) -\n                                    dataLabelBox.height / 2\n                            });\n                        }\n                    }\n\n                    // Adding event to target symbol for handling tooltip\n                    if (tooltip) {\n                        targetEvents.push(addEvent(\n                            targetSymGraphic.element,\n                            'mouseover',\n                            function () {\n                                point.setState('hover');\n\n                                if (!onPoint) {\n                                    tooltip.refresh({\n                                        plotX: inverted ? xAxisLength : 0,\n                                        plotY: point.shapeArgs.y,\n                                        series: point.series,\n                                        x: valueX,\n                                        y: valueY,\n                                        category: point.category,\n                                        color: point.color,\n                                        colorIndex: point.colorIndex,\n                                        name: point.name,\n                                        percentage: point.percentage,\n                                        total: point.total,\n                                        stackTotal: point.stackTotal,\n                                        getLabelConfig: point.getLabelConfig,\n                                        tooltipFormatter: point.tooltipFormatter\n                                    });\n                                } else {\n                                    tooltip.refresh(point);\n                                }\n                            }\n                        ));\n\n                        targetEvents.push(addEvent(\n                            targetSymGraphic.element,\n                            'mouseout',\n                            function () {\n                                point.setState('normal');\n                                tooltip.hide();\n                            }\n                        ));\n\n                        series.targetEvents = targetEvents;\n                    }\n\n                    /* = if (build.classic) { =*/\n                    // Setting style to target symbol\n                    targetSymGraphic.attr({\n                        fill: pick(\n                            pointTargetOptions.color,\n                            seriesTargetOptions.color,\n                            pointOptions.color,\n                            (series.zones.length && (point.getZone.call({\n                                series: series,\n                                x: valueX,\n                                y: valueY,\n                                options: {}\n                            }).color || series.color)) || undefined,\n                            point.color,\n                            series.color\n                        ),\n                        stroke: pick(\n                            pointTargetOptions.borderColor,\n                            seriesTargetOptions.borderColor,\n                            point.borderColor,\n                            seriesOptions.borderColor\n                        ),\n                        'stroke-width': pick(\n                            pointTargetOptions.borderWidth,\n                            seriesTargetOptions.borderWidth,\n                            point.borderWidth,\n                            seriesOptions.borderWidth\n                        )\n                    });\n\n                    // Setting style to target line, if exists\n                    if (showLine) {\n                        targetLinGraphic.attr({\n                            stroke: pick(\n                                pointTargetOptions.lineColor,\n                                seriesTargetOptions.lineColor,\n                                point.borderColor,\n                                seriesOptions.borderColor\n                            ),\n                            'stroke-width': lineWidth\n                        });\n                    }\n                    /* = } =*/\n\n                    // Add styles\n                    if (targetSymGraphic) {\n                        targetSymGraphic.addClass(\n                            point.getClassName() + ' highcharts-' +\n                                series.type + '-target',\n                            true\n                        );\n                    }\n\n                    if (targetLinGraphic) {\n                        targetLinGraphic.addClass(\n                            point.getClassName() +\n                                ' highcharts-lineargauge-target-line',\n                            true\n                        );\n                    }\n                } else if (targetSymGraphic) {\n                    point.targetSymGraphic = targetSymGraphic.destroy();\n\n                    if (targetLinGraphic) {\n                        point.targetLinGraphic = targetLinGraphic.destroy();\n                    }\n                }\n            });\n        }\n    }, {\n        /**\n         * Lineargauge shape\n         */\n        shape: 'target',\n        /**\n         * Destroys target symbol and line graphics.\n         */\n        destroy: function () {\n            var point = this,\n                targetSymGraphic = point.targetSymGraphic,\n                targetLinGraphic = point.targetLinGraphic;\n\n            if (targetSymGraphic) {\n                targetSymGraphic = targetSymGraphic.destroy();\n            }\n\n            if (targetLinGraphic) {\n                targetLinGraphic = targetLinGraphic.destroy();\n            }\n\n            // Deleting target events\n            point.series.targetEvents.forEach(function (targetEvent) {\n                targetEvent();\n            });\n\n            columnProto.pointClass.prototype.destroy.apply(point, arguments);\n        }\n    });\n\n/**\n * A `lineargauge` series. If the [type](#series.lineargauge.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * For options that apply to multiple series, it is recommended to add\n * them to the [plotOptions.series](#plotOptions.series) options structure.\n * To apply to all series of this specific type, apply it to [plotOptions.\n * lineargauge](#plotOptions.lineargauge).\n *\n * @type {Object}\n * @since 6.0.0\n * @extends series,plotOptions.lineargauge\n * @excluding dataParser,dataURL\n * @product highcharts\n * @apioption series.lineargauge\n */\n\n/**\n * Display individual target on a point or alongside the `yAxis`.\n *\n * @type {Boolean}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.onPoint\n */\n\n/**\n * Whether to display or hide individual additional column along with the target.\n *\n * @type {Boolean}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.showColumn\n */\n\n/**\n * Show individual additional line coming out of the target.\n *\n * @type {Boolean}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.showLine\n */\n\n/**\n * Individual length of the base part of the target (similar to [dial.baseLength](#plotOptions.gauge.dial.baseLength)).\n * Can be pixel value or percentage value based on [length](#plotOptions.lineargauge.targetOptions.length).\n *\n * @type {Number|String}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.baseLength\n */\n\n/* = if (build.classic) { =*/\n/**\n * Individual border color of the symbol representing the target. When\n * not set, point's border color is used.\n *\n * In styled mode, target border color can be set with the `.highcharts-lineargauge-target-symbol` class.\n *\n * @type {Color}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.borderColor\n */\n\n/**\n * Individual border width of the symbol representing the target. When\n * not set, point's border width is used.\n *\n * In styled mode, target border color can be set with the `.highcharts-lineargauge-target-symbol` class.\n *\n * @type {Number}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.borderWidth\n */\n\n/**\n * Individual color of the symbol representing the target. When\n * not set, point's color is used.\n *\n * In styled mode, target color can be set with the `.highcharts-lineargauge-target-symbol` class.\n *\n * @type {Color}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.color\n */\n/* = } =*/\n\n/**\n * Individual indentation on the upper part of the target symbol.\n *\n * Can be pixel value or percentage value based on [length](#plotOptions.lineargauge.targetOptions.length).\n *\n * @type {Number|String}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.indent\n */\n\n/* = if (build.classic) { =*/\n/**\n * Individual color of the additional target line. When\n * not set, point's border color is used.\n *\n * In styled mode, target color can be set with the `.highcharts-lineargauge-target-line` class.\n *\n * @type {Color}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.lineColor\n */\n\n/**\n * Individual width of the additional target line. When\n * not set, point's border width is used.\n *\n * In styled mode, target border color can be set with the `.highcharts-lineargauge-target-line` class.\n *\n * @type {Number}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.lineWidth\n */\n/* = } =*/\n\n/**\n * The zIndex of individual target line.\n *\n * @type {Number}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.lineZIndex\n */\n\n/**\n * Individual total length of the target.\n * Can be pixel value or percentage value based on column point's width.\n *\n * @type {Number|String}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.length\n */\n\n/**\n * Individual width of the target.\n * Can be pixel value or percentage value based on column point's width.\n *\n * @type {Number|String}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.width\n */\n\n/**\n * The zIndex of the target symbol.\n *\n * @type {Number}\n * @since 6.0.0\n * @product highcharts\n * @apioption series.lineargauge.data.targetOptions.zIndex\n */\n\n// //////////////////////////////////////////////////////////////////////////////\n\n// Common options options for all the gauges\nvar commonOptions = {\n    chart: {\n        inverted: true,\n        type: 'lineargauge',\n        marginLeft: 20,\n        plotBorderWidth: 0.5\n    },\n    credits: {\n        enabled: false\n    },\n    exporting: {\n        enabled: true\n    },\n    legend: {\n        enabled: false\n    },\n    xAxis: {\n        tickWidth: 0,\n        lineWidth: 0,\n        labels: {\n            enabled: false\n        }\n    },\n    yAxis: {\n        min: 0,\n        max: 100,\n        tickInterval: 10,\n        tickLength: 10,\n        tickWidth: 1,\n        minorGridLineWidth: 0,\n        minorTickInterval: 'auto',\n        minorTickLength: 5,\n        minorTickWidth: 1,\n        title: {\n            text: ''\n        }\n    },\n    plotOptions: {\n        series: {\n            pointPadding: 0,\n            borderWidth: 1,\n            borderColor: '#FFFFFF',\n            color: '#000000',\n            targetOptions: {\n                length: '150%',\n                width: '100%',\n                baseLength: '0%',\n                indent: '20%',\n                lineWidth: 1,\n                lineZIndex: 1\n            },\n            dataLabels: {\n                enabled: true\n            }\n        }\n    }\n};\n\nHighcharts.chart('container1', Highcharts.merge(commonOptions, {\n    title: {\n        text: 'Target on axis, with line enabled, column disabled'\n    },\n    yAxis: {\n        plotBands: [{\n            from: 0,\n            to: 20,\n            color: '#666'\n        }, {\n            from: 20,\n            to: 70,\n            color: '#999'\n        }, {\n            from: 70,\n            to: 100,\n            color: '#bbb'\n        }]\n    },\n    series: [{\n        onPoint: false,\n        showColumn: false,\n        showLine: true,\n        data: [85]\n    }]\n}));\n\nHighcharts.chart('container2', Highcharts.merge(commonOptions, {\n    title: {\n        text: 'Target on point, with line disabled, column disabled'\n    },\n    yAxis: {\n        plotBands: [{\n            from: 0,\n            to: 20,\n            color: '#666'\n        }, {\n            from: 20,\n            to: 70,\n            color: '#999'\n        }, {\n            from: 70,\n            to: 100,\n            color: '#bbb'\n        }]\n    },\n    series: [{\n        onPoint: true,\n        showColumn: false,\n        showLine: false,\n        data: [36]\n    }]\n}));\n\nHighcharts.chart('container3', Highcharts.merge(commonOptions, {\n    title: {\n        text: 'Target on point, with line disabled, column enabled'\n    },\n    yAxis: {\n        plotBands: [{\n            from: 0,\n            to: 20,\n            color: '#666'\n        }, {\n            from: 20,\n            to: 70,\n            color: '#999'\n        }, {\n            from: 70,\n            to: 100,\n            color: '#bbb'\n        }]\n    },\n    series: [{\n        onPoint: true,\n        showColumn: true,\n        showLine: false,\n        data: [73]\n    }]\n}));","css":"#container1,\n#container2,\n#container3 {\n    min-width: 300px;\n    max-width: 800px;\n    height: 120px;\n    margin: 0 auto;\n}\n","html":"\n<div id=\"container1\"></div>\n<div id=\"container2\"></div>\n<div id=\"container3\"></div>","npm":"// 安装\nnpm install highcharts@11.0.0 --save\n\n// import 模块 \nimport Highcharts from 'highcharts';\n\n// 初始化模块\n","scripts":["https://code.highcharts.com/11.0.0/highcharts.js"]}