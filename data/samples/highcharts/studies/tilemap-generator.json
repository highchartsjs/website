{"js":"// Tilemap generator plugin\n(function (H) {\n    /*\n        Algorithm:\n        1. Sort all areas by X value (center)\n        2. Go through and \"lift\" the areas to their correct y-tiles based on\n            where they belong relative to the lowest area, using the average\n            area size as tilesize.\n        3. Now shrink into tiles in the X dimension, by splitting by tilesize.\n            Go through and find the next element that has an area that is more\n            than a tilesize away. Compress all elements between into a single\n            tile.\n        4. If multiple areas are on the same tile, we deal with that as follows:\n            - Place the largest of the areas on the ideal tile.\n            - Subsequent areas are placed around the ideal tile by calculating\n                which of the 8 closest positions to this tile has the least\n                negative impact on the relations of the whole grid.\n    */\n\n\n    var each = H.each,\n        map = H.map,\n        filter = H.grep,\n        reduce = H.reduce,\n        extend = H.extend;\n\n\n    // Sort array of areas by x or y center value\n    // Dimension can be 'x' or 'y'. If unassigned, 'x' is assumed.\n    function sortAreasByCenter(areas, dimension) {\n        var d = dimension || 'x';\n        return areas.sort(function (a, b) {\n            return a.center[d] - b.center[d];\n        });\n    }\n\n\n    // Utility function to check if a string ends with a substring\n    function endsWith(str, search) {\n        return str.substr(str.length - search.length) === search;\n    }\n\n\n    // Utility function to check if a string starts with a substring\n    function startsWith(str, search) {\n        return str.lastIndexOf(search, 0) === 0;\n    }\n\n\n    // Explode one dimensional array of areas into a 2D grid, where a threshold\n    // value determines how far from the lowest area's center an area's center\n    // has to be in the set dimension to shift it up a row. This stacks, so if\n    // an area center value is 2x deltaThreshold away, it will be shifted 2\n    // rows. In other words, the lowest centers will stay at the first row, and\n    // areas are shifted up the grid the farther away they are in the chosen\n    // dimension. Areas retain their original column index. The grid is\n    // normalized to avoid negative indicies.\n    //\n    // Dimension can be 'x' or 'y'. If unassigned, 'y' is assumed.\n    /*\n\n        -1, 2, 3, 4, 5, 6, 7, 8, 9-\n\n        to\n\n        - , 2,  ,  ,  ,  , 7,  , 9-\n        - ,  , 3,  ,  , 6,  ,  ,  -\n        -1,  ,  ,  ,  ,  ,  , 8,  -\n        - ,  ,  , 4, 5,  ,  ,  ,  -\n\n    */\n    function explodeToGrid(areas, deltaThreshold, dimension) {\n        var grid = [],\n            direction = dimension || 'y',\n            rowIx,\n            i = areas.length,\n            min = Infinity;\n\n        // Find min value\n        while (i--) {\n            if (areas[i].center[direction] < min) {\n                min = areas[i].center[direction];\n            }\n        }\n\n        // Make the grid\n        i = areas.length;\n        while (i--) {\n            rowIx = Math.floor(\n                (areas[i].center[direction] - min) / deltaThreshold\n            );\n            if (!grid[rowIx]) {\n                grid[rowIx] = [];\n            }\n            grid[rowIx][i] = areas[i];\n        }\n\n        return grid;\n    }\n\n\n    // Shift a grid to the left and up one row/col by adding null elements.\n    function shiftGrid(grid) {\n        grid.unshift(null);\n        each(grid, function (row) {\n            if (row && row.length) {\n                row.unshift(null);\n            }\n        });\n    }\n\n\n    // Compress grid columns into tiles of size \"tilesize\". Each tile is an\n    // array and may contain multiple areas.\n    //\n    // Dimension can be 'x' or 'y', assumed 'x' if undefined.\n    function compressGridColumns(grid, tilesize, dimension) {\n        var tiles = [],\n            tileIx,\n            direction = dimension || 'x',\n            min = Infinity;\n\n        // Find reference minimum in the direction\n        if (direction === 'x') {\n            each(grid, function (row) {\n                if (row.length && row[0] && row[0].center.x < min) {\n                    min = row[0].center.x;\n                }\n            });\n        } else {\n            if (grid.length) {\n                each(grid[0], function (cell) {\n                    if (cell && cell.center.y < min) {\n                        min = cell.center.y;\n                    }\n                });\n            }\n        }\n\n        // Rows\n        for (var i = 0, len = grid.length; i < len; ++i) {\n            // Split columns into tiles\n            if (grid[i]) {\n                tiles[i] = [];\n                // Columns\n                for (var j = 0, rowLen = grid[i].length; j < rowLen; ++j) {\n                    if (!grid[i][j]) {\n                        continue;\n                    }\n\n                    // Ideal tile for this area\n                    tileIx = Math.floor(\n                        (grid[i][j].center[direction] - min) / tilesize\n                    );\n\n                    // Add area to tile\n                    if (!tiles[i][tileIx]) {\n                        tiles[i][tileIx] = [];\n                    }\n                    tiles[i][tileIx].push(grid[i][j]);\n                }\n            }\n        }\n\n        return tiles;\n    }\n\n\n    // Compute 2D deviation value for a grid. The deviation value is the sum\n    // of the differences between each area's ideal distance to each area in the\n    // grid and its actual distance (euclidean).\n    function getGridDeviation(grid, tilesize) {\n        var deviation = 0,\n            getTileDeviation = function (aCoords, bCoords) {\n                var a = grid[aCoords.row][aCoords.col],\n                    b = grid[bCoords.row][bCoords.col],\n                    centerXDistance = (a.center.x - b.center.x) /\n                        tilesize.width,\n                    centerYDistance = (a.center.y - b.center.y) /\n                        tilesize.height,\n                    actualXDistance = aCoords.col - bCoords.col,\n                    actualYDistance = aCoords.row - bCoords.row,\n                    idealEuclidean = centerXDistance * centerXDistance +\n                        centerYDistance * centerYDistance,\n                    actualEuclidean = actualXDistance * actualXDistance +\n                        actualYDistance * actualYDistance;\n\n                return Math.abs(actualEuclidean - idealEuclidean);\n            };\n\n        // Loop over all tiles\n        for (var row = 0, rowLen = grid.length; row < rowLen; ++row) {\n            if (!grid[row]) {\n                continue;\n            }\n            for (var col = 0, colLen = grid[row].length; col < colLen; ++col) {\n                if (!grid[row][col]) {\n                    continue;\n                }\n                // Compute deviation against all tiles further up the grid\n                for (var dRow = row; dRow < rowLen; ++dRow) {\n                    if (!grid[dRow]) {\n                        continue;\n                    }\n                    for (var dCol = dRow === row ? col + 1 : 0,\n                        dColLen = grid[dRow].length;\n                        dCol < dColLen; ++dCol\n                    ) {\n                        if (grid[dRow][dCol]) {\n                            deviation += getTileDeviation(\n                                // Area\n                                {\n                                    row: row,\n                                    col: col\n                                },\n                                // Deviation area\n                                {\n                                    row: dRow,\n                                    col: dCol\n                                }\n                            );\n                        }\n                    }\n                }\n            }\n        }\n        return deviation;\n    }\n\n\n    // Get the index of the largest area in an array of areas\n    function getLargestAreaIx(areas) {\n        var i = areas.length,\n            largestIx = 0,\n            largestArea = 0;\n        while (i--) {\n            if (areas[i].extremes.width * areas[i].extremes.height >\n                largestArea) {\n                largestIx = i;\n                largestArea = areas[i].extremes.width *\n                    areas[i].extremes.height;\n            }\n        }\n        return largestIx;\n    }\n\n\n    // Insert an area into a grid, shifting the existing areas accordingly.\n    // Returns new grid with area inserted.\n    function insertInGrid(baseGrid, area, position, direction) {\n        var grid = [],\n            shift = false,\n            lowerRow = position[0] - 1,\n            upperRow = position[0] + 1,\n            row,\n            i,\n            newRow;\n\n        // Copy baseGrid, avoid altering source\n        for (i = 0; i < baseGrid.length; ++i) {\n            newRow = [];\n            if (baseGrid[i]) {\n                for (var j = 0; j < baseGrid[i].length; ++j) {\n                    newRow.push(baseGrid[i][j]);\n                }\n            }\n            grid.push(newRow);\n        }\n\n        // Determine if we need to shift the row horizontally\n        if (direction === 'left' ||\n            direction === 'leftTop' ||\n            direction === 'leftBottom') {\n            shift = true;\n        }\n\n        if (direction === 'centerBottom') {\n            // Copy over the next cell to each position to simulate a vertical\n            // shift.\n            for (i = 0; i < lowerRow; ++i) {\n                if (!grid[i]) {\n                    grid[i] = [];\n                }\n                grid[i][position[1]] = grid[i + 1] && grid[i + 1][position[1]];\n            }\n            if (!grid[lowerRow]) {\n                grid[lowerRow] = [];\n            }\n            grid[lowerRow][position[1]] = area;\n        } else if (direction === 'centerTop') {\n            // Same as for centerBottom, but start from end of the grid.\n            for (i = grid.length; i > upperRow; --i) {\n                if (!grid[i]) {\n                    grid[i] = [];\n                }\n                grid[i][position[1]] = grid[i - 1] && grid[i - 1][position[1]];\n            }\n            if (!grid[upperRow]) {\n                grid[upperRow] = [];\n            }\n            grid[upperRow][position[1]] = area;\n        } else {\n            // All of the others have a horizontal shift, so just splice and\n            // insert.\n            if (endsWith(direction, 'Top')) {\n                row = upperRow;\n            } else if (endsWith(direction, 'Bottom')) {\n                row = lowerRow;\n            } else {\n                row = position[0];\n            }\n\n            if (!grid[row]) {\n                grid[row] = [];\n            }\n\n            if (shift) {\n                // Left\n                grid[row].shift();\n                // Can't splice on nothing so insert nulls\n                while (grid[row].length < position[1] - 1) {\n                    grid[row].push(null);\n                }\n                grid[row].splice(position[1] - 1, 0, area);\n            } else {\n                // Right\n                while (grid[row].length < position[1] + 1) {\n                    grid[row].push(null);\n                }\n                grid[row].splice(position[1] + 1, 0, area);\n            }\n        }\n\n        return grid;\n    }\n\n\n    // Create an array of grids, where an overflow area has been inserted in\n    // each possible position around a point. Assumes the baseGrid has a margin\n    // of at least 1 to left and bottom to allow for shifts.\n    function getInsertionGrids(baseGrid, overflow) {\n        var insertionGrids = [],\n            baseTile = baseGrid[overflow.row][overflow.col];\n        each(filter(['left', 'leftTop', 'centerTop', 'rightTop', 'right',\n            'rightBottom', 'centerBottom', 'leftBottom'], function (dir) {\n            // Filter out positions we don't want to use for this overflow\n            return !startsWith(dir,\n                baseTile.center.x > overflow.area.center.x ?\n                    'right' : // Base tile should be to the right or center\n                    'left') && // Base tile should be to the left or center\n                   !endsWith(dir,\n                       baseTile.center.y > overflow.area.center.y ?\n                           'Top' : // Base tile should be on top or center\n                           'Bottom'); // Base tile should be below or center\n        }),\n        function (dir) {\n            // Get insertion grids for each position\n            insertionGrids.push({\n                grid: insertInGrid(baseGrid, overflow.area,\n                    [overflow.row, overflow.col], dir),\n                dir: dir\n            });\n        });\n        return insertionGrids;\n    }\n\n\n    // Remove empty rows and columns at the beginning of a grid\n    function trimGrid(grid) {\n        var minRow = Infinity, // Min row ix;\n            minCol = Infinity;\n        for (var i = 0; i < grid.length; ++i) {\n            if (grid[i] && grid[i].length) {\n                for (var j = 0; j < grid[i].length; ++j) {\n                    if (grid[i][j]) {\n                        minRow = i < minRow ? i : minRow;\n                        minCol = j < minCol ? j : minCol;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // We have the minimums, just shift the grid.\n        return map(grid.slice(minRow), function (row) {\n            return row.slice(minCol);\n        });\n    }\n\n\n    // Insert overflows into a grid using deviationValue computation to find\n    // best position. Returns new grid with overflows inserted or old grid if\n    // no overflows.\n    function insertOverflows(grid, overflows, tilesize) {\n        var crushed = grid,\n            optimalGridVal,\n            optimalGridIx = 0,\n            g,\n            gridVal,\n            grids = [],\n            shift = 0,\n            colShift,\n            rowShiftIx,\n            rowShift;\n\n        for (var i = 0, oLen = overflows.length, of; i < oLen; ++i) {\n            of = overflows[i];\n\n            // Always make space for the grid to overflow\n            shiftGrid(crushed);\n            ++shift;\n\n            // Get grids for each insert position for this overflow into an\n            // array\n            grids = getInsertionGrids(crushed, {\n                area: of.area,\n                row: of.row + shift, // Compensate for the constant shift\n                col: of.col + shift\n            });\n\n            // Find the optimal grid\n            g = grids.length;\n            optimalGridVal = Infinity;\n            while (g--) {\n                gridVal = getGridDeviation(grids[g].grid, tilesize);\n                if (gridVal < optimalGridVal) {\n                    optimalGridVal = gridVal;\n                    optimalGridIx = g;\n                }\n            }\n\n            // Update with the most optimal insertion\n            crushed = grids[optimalGridIx].grid;\n\n            // Now we need to update the overflow coordinates to fit the new\n            // grid. First find out what to shift.\n            rowShiftIx = 0;\n            rowShift = 0;\n            colShift = 0;\n            switch (grids[optimalGridIx].dir) {\n            case 'left':\n                rowShiftIx = of.row;\n                rowShift = -1;\n                break;\n            case 'right':\n                rowShiftIx = of.row;\n                rowShift = 1;\n                break;\n            case 'centerTop':\n                colShift = 1;\n                break;\n            case 'leftTop':\n                rowShiftIx = of.row + 1;\n                rowShift = -1;\n                break;\n            case 'rightTop':\n                rowShiftIx = of.row + 1;\n                rowShift = 1;\n                break;\n            case 'centerBottom':\n                colShift = -1;\n                break;\n            case 'rightBottom':\n                rowShiftIx = of.row - 1;\n                rowShift = 1;\n                break;\n            case 'leftBottom':\n                rowShiftIx = of.row - 1;\n                rowShift = -1;\n                break;\n            default:\n                return;\n            }\n            // colShift now holds the amount that the column has shifted.\n            // rowShift holds the same for the row, and rowShiftIx specifies\n            // which row.\n\n            // Loop over all remaining overflows and change them.\n            for (var j = i + 1; j < oLen; ++j) {\n                if (overflows[j].row === rowShiftIx &&\n                    ((overflows[j].col < of.col && rowShift < 0) ||\n                    (overflows[j].col > of.col && rowShift > 0))\n                ) {\n                    // This row has shifted horizontally, change overflow col to\n                    // follow\n                    overflows[j].col += rowShift;\n                }\n                if (overflows[j].col === of.col &&\n                    ((overflows[j].row < of.row && colShift < 0) ||\n                    (overflows[j].row > of.row && colShift > 0))\n                ) {\n                    // This column has shifted horizontally, change overflow row\n                    // to follow\n                    overflows[j].row += colShift;\n                }\n            }\n        }\n\n        // Remove excessive margins caused by shifts\n        return trimGrid(crushed);\n    }\n\n\n    // Deflate a compressed 3D tile grid so that no tiles contain more than one\n    // area. This is done by overflowing the stacked tiles and expanding the\n    // grid.\n    //\n    // reverseOverflows can be set to true to reverse the order of overflow\n    //  insertions\n    //\n    // Algorithm:\n    //  For tiles with multiple areas, we insert the center area in the tile.\n    //  Subsequent areas are inserted by computing a deviationValue for each of\n    //  the possible insertion points, and selecting the insertion with the\n    //  smallest deviationValue.\n    function crushTileGrid(grid, tilesize, reverseOverflows) {\n        var crushed = [],\n            overflows = [],\n            centerArea;\n\n        // First add the simple areas and the center areas of the stacked tiles\n        for (var row = 0, rowLen = grid.length; row < rowLen; ++row) {\n            if (!grid[row]) {\n                continue;\n            }\n            crushed[row] = [];\n            for (var col = 0, colLen = grid[row].length, numAreas;\n                col < colLen; ++col\n            ) {\n                if (!grid[row][col]) {\n                    continue;\n                }\n                numAreas = grid[row][col].length;\n                if (numAreas === 1) {\n                    crushed[row][col] = grid[row][col][0];\n                } else if (numAreas > 1) {\n                    centerArea = getLargestAreaIx(grid[row][col]);\n                    for (var a = 0; a < numAreas; ++a) {\n                        // Insert center area normally\n                        if (a === centerArea) {\n                            crushed[row][col] = grid[row][col][centerArea];\n                            continue;\n                        }\n                        // Overflow for this area. Pick up these after all\n                        // others are placed.\n                        overflows.push({\n                            area: grid[row][col][a],\n                            row: row,\n                            col: col\n                        });\n                    }\n                }\n            }\n        }\n\n        return insertOverflows(\n            crushed,\n            reverseOverflows ? overflows.reverse() : overflows,\n            tilesize\n        );\n    }\n\n\n    // Get average boundary box size in x and y dimensions\n    // Discards outliers using interquartile ranges (Tukey's alg)\n    function getAverageAreaSize(areas) {\n        var compareNumbers = function (a, b) {\n                return a - b;\n            },\n            xSizes = map(areas, function (area) {\n                return area.extremes.width;\n            }).sort(compareNumbers),\n            ySizes = map(areas, function (area) {\n                return area.extremes.height;\n            }).sort(compareNumbers),\n            q1 = Math.floor(areas.length / 4),\n            q3 = Math.floor(areas.length / 4 * 3),\n            xIQR = xSizes[q3] - xSizes[q1],\n            xMin = xSizes[q1] - 1.5 * xIQR,\n            xMax = xSizes[q3] + 1.5 * xIQR,\n            yIQR = ySizes[q3] - ySizes[q1],\n            yMin = ySizes[q1] - 1.5 * yIQR,\n            yMax = ySizes[q3] + 1.5 * yIQR,\n            // Widths and heights within statistically significant bounds\n            xProcessed = filter(xSizes, function (item) {\n                return item > xMin && item < xMax;\n            }),\n            yProcessed = filter(ySizes, function (item) {\n                return item > yMin && item < yMax;\n            });\n\n        return {\n            width: reduce(xProcessed, function (a, b) {\n                return a + b;\n            }, 0) / xProcessed.length,\n\n            height: reduce(yProcessed, function (a, b) {\n                return a + b;\n            }, 0) / yProcessed.length\n        };\n    }\n\n\n    // Get the extremes and center point of a GeoJSON feature.\n    // labelCenter specifies whether to use the data label as center if possible\n    function getFeatureMetrics(feature, labelCenter) {\n        var type = feature.geometry.type,\n            coords = feature.geometry.coordinates,\n            flattened = [],\n            extremes = {\n                xMin: Infinity,\n                xMax: -Infinity,\n                yMin: Infinity,\n                yMax: -Infinity\n            },\n            center = [];\n\n        // Flatten feature into list of coordinates\n        switch (type) {\n        case 'MultiPolygon':\n            each(coords, function (polygon) {\n                each(polygon, function (ring) {\n                    each(ring, function (pair) {\n                        flattened.push(pair);\n                    });\n                });\n            });\n            break;\n\n        case 'Polygon':\n            each(coords, function (ring) {\n                each(ring, function (pair) {\n                    flattened.push(pair);\n                });\n            });\n            break;\n\n        default:\n            return;\n        }\n\n        // Find extremes of coordinates\n        each(flattened, function (pair) {\n            var x = parseFloat(pair[0]),\n                y = parseFloat(pair[1]);\n            if (x < extremes.xMin) {\n                extremes.xMin = x;\n            }\n            if (x > extremes.xMax) {\n                extremes.xMax = x;\n            }\n            if (y < extremes.yMin) {\n                extremes.yMin = y;\n            }\n            if (y > extremes.yMax) {\n                extremes.yMax = y;\n            }\n        });\n        extremes.width = Math.abs(extremes.xMax - extremes.xMin);\n        extremes.height = Math.abs(extremes.yMax - extremes.yMin);\n\n        // Get label point and use it as center\n        if (feature.properties['hc-middle-x'] && labelCenter) {\n            center.push(\n                extremes.xMin + (extremes.xMax - extremes.xMin) *\n                feature.properties['hc-middle-x']\n            );\n        } else {\n            center.push((extremes.xMax + extremes.xMin) / 2);\n        }\n        if (feature.properties['hc-middle-y'] && labelCenter) {\n            center.push(\n                extremes.yMin + (extremes.yMax - extremes.yMin) *\n                (1 - feature.properties['hc-middle-y']) // y is reversed\n            );\n        } else {\n            center.push((extremes.yMax + extremes.yMin) / 2);\n        }\n\n        return {\n            center: center,\n            extremes: extremes\n        };\n    }\n\n\n    // Create tilemap data structure from GeoJSON map\n    // A resolution factor parameter can be passed in for each dimension to\n    //  increase or decrease the tilesize resolution of the conversion.\n    // The reverseAlg parameter reverses the order in which overflowing tiles\n    //  are inserted. This might lead to better results with some maps.\n    // useLabelCenter is on by default, and determines whether to use the center\n    //  of the data label position as area centers, or the center of the\n    //  bounding box.\n    // The excludeList parameter allows for exclusion of a set of areas by their\n    //  ids.\n    H.geojsonToTilemapData = function (\n        geojson, xResolutionFactor, yResolutionFactor, reverseAlg,\n        useLabelCenter, excludeList\n    ) {\n        var areas = sortAreasByCenter(\n            // Reduce geojson to objects with center, bounding box, and metadata\n            // sorted by center X position.\n                filter(map(geojson.features, function (area) {\n                    var metrics = getFeatureMetrics(\n                        area, H.pick(useLabelCenter, true)\n                    );\n                    return metrics && extend({\n                        center: {\n                            x: metrics.center[0],\n                            y: metrics.center[1]\n                        },\n                        extremes: metrics.extremes,\n                        id: area.id\n                    }, area.properties) || null;\n                }), function (area) {\n                    // Remove areas that don't have metrics (line geom etc.),\n                    // as well as excluded areas.\n                    var excluded = false,\n                        i = excludeList.length;\n                    while (i--) {\n                        if (area.id === excludeList[i]) {\n                            excluded = true;\n                            break;\n                        }\n                    }\n                    return area !== null && !excluded;\n                })\n            ),\n            // Find average tile size to use for creating a grid\n            tilesize = getAverageAreaSize(areas),\n            grid;\n\n        // Add resolution factor if present\n        tilesize.width /= Math.log(xResolutionFactor || 1) + 1;\n        tilesize.height /= Math.log(yResolutionFactor || 1) + 1;\n\n        // Create a grid from the areas\n        grid = crushTileGrid(\n            compressGridColumns(\n                explodeToGrid(areas, tilesize.height),\n                tilesize.width\n            ),\n            tilesize,\n            reverseAlg\n        );\n\n        // We have to flatten the grid into a one dimensional array with x/y\n        // axis coordinates for Highcharts\n        return filter(reduce(grid, function (accumulator, row, y) {\n            // Reduce the grid into a flat array with x/y\n            return accumulator.concat(\n                row && map(row, function (cell, x) {\n                    return cell && extend(cell, {\n                        x: x,\n                        y: y\n                    }) || null;\n                }) || []\n            );\n        }, []), function (point) {\n            // Remove null points\n            return point !== null;\n        });\n    };\n\n}(Highcharts));\n\n\n// -----------------------------------------------------------------------------\n// End tilemap generator plugin\n// -----------------------------------------------------------------------------\n\n\n/* UI below, partially based on all-maps demo */\n\n\nvar baseMapPath = 'https://code.highcharts.com/mapdata/',\n    showDataLabels = true,\n    mapCount = 0,\n    searchText,\n    mapOptions = '',\n    mapChart,\n    tileChart,\n    currentMapKey,\n    currentData,\n    dataAltered,\n    selectedPoint;\n\n\n// Create/update tile chart. Called on changes to alg params or map load.\nfunction generateTileChart() {\n    var shapeType = $('#shapeType').val(),\n        xRes = $('#xRes').val(),\n        yRes = $('#yRes').val(),\n        invert = $('#invert').prop('checked'),\n        reverseAlg = $('#reverse').prop('checked'),\n        labelCenter = $('#labelCenter').prop('checked'),\n        excludeList = $('#exclude').val(),\n        data,\n        options,\n        maxY,\n        mapLen = Highcharts.maps[currentMapKey].features.length,\n        outputData = function () {\n            $('#outputData').val(JSON.stringify(\n                currentData.map(point => {\n                    var filterProps = ['center', 'extremes', 'hc-middle-y',\n                        'hc-middle-x', 'selected', 'color'];\n                    filterProps.forEach(prop => delete point[prop]);\n                    return point;\n                }), null,\n                $('#prettyprint').prop('checked') ? 2 : null\n            ));\n        },\n        swapPoints = function (a, b) {\n            var bX = b.x,\n                bY = b.y,\n                aChanged = false,\n                bChanged = false;\n\n            // First change it in output data\n            currentData.forEach(point => {\n                if (!aChanged && point.x === a.x && point.y === a.y) {\n                    point.x = b.x;\n                    point.y = b.y;\n                    aChanged = true;\n                } else if (!bChanged && point.x === b.x && point.y === b.y) {\n                    point.x = a.x;\n                    point.y = a.y;\n                    bChanged = true;\n                }\n            });\n\n            outputData();\n\n            // Now change it in actual points\n            a.select(false);\n            a.update({\n                color: Highcharts.getOptions().colors[0]\n            });\n            if (b.update) { // b is a point\n                b.update({\n                    x: a.x,\n                    y: a.y\n                });\n            } else {\n                // Should b be a point?\n                for (var i = 0, pLen = a.series.points.length; i < pLen; ++i) {\n                    if (a.series.points[i].x === b.x &&\n                        a.series.points[i].y === b.y) {\n                        a.series.points[i].update({\n                            x: a.x,\n                            y: a.y\n                        });\n                    }\n                }\n            }\n            a.update({\n                x: bX,\n                y: bY\n            });\n            if (a !== b) {\n                dataAltered = true;\n            }\n        };\n\n    if (excludeList) {\n        excludeList = excludeList.split(',').map(function (item) {\n            return item.trim();\n        });\n    }\n\n    // Warn for data loss\n    if (dataAltered && !window.confirm(\n        'This will discard data changes. Proceed?'\n    )) {\n        return;\n    }\n\n    // Warn for huge maps\n    if (mapLen > 300 && !window.confirm('This map contains ' + mapLen +\n        ' areas. Converting this much data could take a while. Continue?')) {\n        return;\n    }\n\n    data = Highcharts.geojsonToTilemapData(\n        Highcharts.maps[currentMapKey],\n        xRes, yRes, reverseAlg, labelCenter, excludeList\n    );\n\n    if (invert) {\n        // Find max Y, since Y axis must be reversed\n        maxY = data.reduce((a, b) => Math.max(a && a.y || 0, b && b.y || 0));\n        data.forEach(point => {\n            var temp = point.x;\n            point.x = maxY - point.y;\n            point.y = temp;\n        });\n    }\n\n    options = {\n        chart: {\n            type: 'tilemap',\n            inverted: invert,\n            events: {\n                click: function (e) {\n                    var x = Math.round(e.xAxis[0].value),\n                        y = Math.round(e.yAxis[0].value);\n\n                    if (selectedPoint) {\n                        swapPoints(selectedPoint, { x: x, y: y });\n                        selectedPoint = null;\n                    }\n                }\n            }\n        },\n        credits: {\n            position: {\n                align: 'center'\n            }\n        },\n        title: {\n            text: 'Click tiles to swap places'\n        },\n        xAxis: {\n            visible: false\n        },\n        yAxis: {\n            visible: false\n        },\n        legend: {\n            enabled: false\n        },\n        tooltip: {\n            pointFormat: '{point.id}: {point.name}'\n        },\n        series: [{\n            data: data,\n            tileShape: shapeType,\n            allowPointSelect: true,\n            dataLabels: {\n                enabled: showDataLabels,\n                format: '{point.name}'\n            },\n            cursor: 'pointer',\n            point: {\n                events: {\n                    click: function () {\n                        var point = this;\n                        if (selectedPoint) {\n                            swapPoints(selectedPoint, point);\n                            selectedPoint = null;\n                        } else {\n                            point.select(true);\n                            point.update({\n                                color: '#601010'\n                            });\n                            selectedPoint = point;\n                        }\n                    }\n                }\n            }\n        }]\n    };\n\n    // Don't use chart.update since we're altering axis extremes outside of\n    // options and there doesn't seem to be a simple way to reset them in\n    // update.\n    if (tileChart) {\n        tileChart.destroy();\n        tileChart = null;\n    }\n\n    tileChart = Highcharts.chart('tileContainer', options);\n\n    dataAltered = false;\n    selectedPoint = null;\n    currentData = data;\n    outputData();\n}\n\n\n// Populate dropdown menu and turn into jQuery UI widgets\n$.each(Highcharts.mapDataIndex, function (mapGroup, maps) {\n    if (mapGroup !== 'version') {\n        mapOptions += '<option class=\"option-header\">' + mapGroup + '</option>';\n        $.each(maps, function (desc, path) {\n            mapOptions += '<option value=\"' + path + '\">' + desc + '</option>';\n            mapCount += 1;\n        });\n    }\n});\nsearchText = 'Search ' + mapCount + ' maps';\nmapOptions = '<option value=\"custom/world.js\">' + searchText + '</option>' + mapOptions;\n$('#mapDropdown').append(mapOptions).combobox();\n\n\n// Change map when item selected in dropdown\n$('#mapDropdown').change(function () {\n    var $selectedItem = $('option:selected', this),\n        mapDesc = $selectedItem.text(),\n        mapKey = this.value.slice(0, -3),\n        javascriptPath = baseMapPath + this.value,\n        isHeader = $selectedItem.hasClass('option-header');\n\n    // Dim or highlight search box\n    if (mapDesc === searchText || isHeader) {\n        $('.custom-combobox-input').removeClass('valid');\n        location.hash = '';\n    } else {\n        $('.custom-combobox-input').addClass('valid');\n        location.hash = mapKey;\n    }\n\n    if (isHeader) {\n        return false;\n    }\n\n    // Show loading\n    if (Highcharts.charts[0]) {\n        Highcharts.charts[0].showLoading('<i class=\"fa fa-spinner fa-spin fa-2x\"></i>');\n    }\n\n    // When the map is loaded or ready from cache...\n    function mapReady() {\n        var mapGeoJSON = Highcharts.maps[mapKey],\n            data = [];\n\n        currentMapKey = mapKey;\n\n        // Generate bogus data for the map\n        $.each(mapGeoJSON.features, function (index, feature) {\n            data.push({\n                key: feature.properties['hc-key'],\n                value: index\n            });\n        });\n\n        // Instantiate chart\n        mapChart = Highcharts.mapChart('mapContainer', {\n            title: {\n                text: null\n            },\n\n            exporting: {\n                buttons: {\n                    contextButton: {\n                        x: -35\n                    }\n                }\n            },\n\n            mapNavigation: {\n                enabled: true,\n                buttonOptions: {\n                    align: 'right',\n                    verticalAlign: 'top'\n                }\n            },\n\n            credits: {\n                position: {\n                    align: 'center'\n                }\n            },\n\n            colorAxis: {\n                min: 0,\n                stops: [\n                    [\n                        0,\n                        '#EFEFFF'\n                    ],\n                    [\n                        0.5,\n                        Highcharts.getOptions().colors[0]\n                    ],\n                    [\n                        1,\n                        Highcharts.color(Highcharts.getOptions().colors[0])\n                            .brighten(-0.5).get()\n                    ]\n                ]\n            },\n\n            legend: {\n                enabled: false\n            },\n\n            series: [{\n                data: data,\n                mapData: mapGeoJSON,\n                joinBy: ['hc-key', 'key'],\n                name: 'Random data',\n                states: {\n                    hover: {\n                        color: Highcharts.getOptions().colors[2]\n                    }\n                },\n                dataLabels: {\n                    enabled: showDataLabels,\n                    formatter: function () {\n                        return mapKey === 'custom/world' || mapKey === 'countries/us/us-all' ?\n                            (this.point.properties && this.point.properties['hc-a2']) :\n                            this.point.name;\n                    }\n                }\n            }, {\n                type: 'mapline',\n                name: 'Separators',\n                data: Highcharts.geojson(mapGeoJSON, 'mapline'),\n                nullColor: 'gray',\n                showInLegend: false,\n                enableMouseTracking: false\n            }]\n        });\n\n        generateTileChart(mapKey);\n    }\n\n    // Check whether the map is already loaded, else load it and\n    // then show it async\n    if (Highcharts.maps[mapKey]) {\n        mapReady();\n    } else {\n        $.getScript(javascriptPath, mapReady);\n    }\n});\n\n\n// Toggle pretty print\n$('#prettyprint').change(function () {\n    $('#outputData').val(JSON.stringify(\n        currentData, null, $('#prettyprint').prop('checked') ? 2 : null)\n    );\n});\n\n\n// Add excluded areas\n$('#exclude').change(generateTileChart);\n\n\n// Select view mode\n$('#shapeType').change(function () {\n    tileChart.series[0].update({\n        tileShape: $('#shapeType').val()\n    });\n});\n\n\n// Toggle algorithm reverse\n$('#reverse').change(generateTileChart);\n\n\n// Toggle data label as center\n$('#labelCenter').change(generateTileChart);\n\n\n// Toggle chart invert\n$('#invert').change(generateTileChart);\n\n\n// Zoom out tile chart\n$('#zoomOut').click(function () {\n    var xe = tileChart.xAxis[0].getExtremes(),\n        ye = tileChart.yAxis[0].getExtremes();\n    tileChart.xAxis[0].setExtremes(xe.min - 1, xe.max + 1);\n    tileChart.yAxis[0].setExtremes(ye.min - 1, ye.max + 1);\n    dataAltered = true;\n});\n\n\n// xResolution change\n$('#xRes').change(generateTileChart);\n$('#xRes').on('input', function () {\n    var val = $('#xRes').val();\n    $('#xResLabel').text(val === '1' ? 'X resolution factor' :\n        'X resolution factor (' + val + ')');\n});\n\n\n// yResolution change\n$('#yRes').change(generateTileChart);\n$('#yRes').on('input', function () {\n    var val = $('#yRes').val();\n    $('#yResLabel').text(val === '1' ? 'Y resolution factor' :\n        'Y resolution factor (' + val + ')');\n});\n\n\n// Toggle enlarge charts\n$('#enlarge').change(function () {\n    if ($('#enlarge').prop('checked')) {\n        $('.verticalLine').hide();\n        $('#mapContainer').addClass('container-expanded');\n        $('#tileContainer').addClass('container-expanded');\n        tileChart.reflow();\n        mapChart.reflow();\n    } else {\n        $('.verticalLine').show();\n        $('#tileContainer').removeClass('container-expanded');\n        $('#mapContainer').removeClass('container-expanded');\n        tileChart.reflow();\n        mapChart.reflow();\n    }\n});\n\n\n// Toggle data labels\n$('#dataLabels').change(function () {\n    showDataLabels = $('#dataLabels').prop('checked');\n    mapChart.series[0].update({\n        dataLabels: {\n            enabled: showDataLabels\n        }\n    });\n    tileChart.series[0].update({\n        dataLabels: {\n            enabled: showDataLabels\n        }\n    });\n});\n\n\n// Trigger change event to load map on startup\nif (location.hash) {\n    $('#mapDropdown').val(location.hash.substr(1) + '.js');\n} else { // for IE9\n    $($('#mapDropdown option')[0]).attr('selected', 'selected');\n}\n$('#mapDropdown').change();\n","css":".loading {\n    margin-top: 10em;\n    text-align: center;\n    color: gray;\n}\n\n#appContainer {\n    width: 1300px;\n}\n\n.container {\n    height: 600px;\n    width: 600px;\n    margin: 20px 24px;\n    float: left;\n}\n\n.container-expanded {\n    height: 800px;\n    width: 1250px;\n    margin: 20px 24px;\n}\n\n.verticalLine {\n    display: block;\n    width: 1px;\n    border-left: 1px solid #000;\n    float: left;\n    height: 600px;\n    margin: 20px 0;\n}\n\n#controls1 {\n    display: inline-block;\n    width: 700px;\n}\n\n#controls2 {\n    display: inline-block;\n    width: 400px;\n}\n\n.checkboxContainer {\n    display: block;\n    margin-bottom: 10px;\n    margin-left: -10px;\n}\n\n#default {\n    display: inline-block;\n}\n\n#appContainer button {\n    border: none;\n    border-radius: 0.3em;\n    background: #a4edba;\n    padding: 0.5em 1.5em;\n    color: black;\n    text-decoration: none;\n    font-size: 1em;\n    white-space: nowrap;\n    cursor: pointer;\n    margin: 0.5em;\n    line-height: 1em;\n    display: inline-block;\n}\n\n#appContainer button:hover {\n    background: #40818b;\n    color: white;\n}\n\n#appContainer button.active {\n    background: #40818b;\n    color: white;\n}\n\n#appContainer input {\n    margin: 10px;\n}\n\n#appContainer input:not([type=\"checkbox\"]) {\n    display: block;\n    width: 90%;\n}\n\n#appContainer textarea {\n    width: 100%;\n    margin: 10px;\n    height: 100px;\n}\n\n.selector .custom-combobox {\n    display: block;\n}\n\n.selector .custom-combobox .custom-combobox-input {\n    font-size: 14px;\n    color: silver;\n    border-radius: 0;\n    height: 24px;\n    display: block;\n    background: url(https://www.highcharts.com/samples/graphics/search.png) 5px 5px no-repeat white;\n    padding: 1px 5px 1px 30px;\n    width: 100%;\n}\n\n.selector .custom-combobox .ui-autocomplete-input:focus {\n    color: black;\n}\n\n.selector .custom-combobox .ui-autocomplete-input.valid {\n    color: black;\n}\n\n.ui-autocomplete {\n    max-height: 500px;\n    overflow: auto;\n}\n\n.ui-autocomplete .option-header {\n    font-style: italic;\n    font-weight: bold;\n    margin: 5px 0;\n    font-size: 1.2em;\n    color: gray;\n}\n\n.ui-button {\n    display: none !important;\n}\n\n.selector .custom-combobox-toggle {\n    display: block;\n    border-radius: 0;\n}\n","html":"<link href=\"https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/base/jquery-ui.css\" rel=\"stylesheet\">\n\n\n<div id=\"appContainer\">\n\t<h1>Tilemap generator</h1>\n\t<p>Load a map from the <a href=\"https://code.highcharts.com/mapdata\" target=\"_blank\">Highmaps Map Collection</a>\n\t\tand convert it to a tilemap. The algorithm will output a best guess for\n\t\tthe loaded map, which can then be edited to produce the desired result. \n\t\tPlay around with the algorithm parameters to find the best combination\n\t\tfor your map. Inverting the chart will swap the X and Y axes, mostly \n\t\tuseful for changing the orientation of honeycomb charts.</p>\n\t<div id=\"controls1\">\n\t\t<div class=\"selector\">\n\t\t\t<label>Load map</label>\n\t\t\t<select id=\"mapDropdown\" class=\"ui-widget combobox\"></select>\n\t\t</div>\n\t\t<label>Exclude areas by ID<input id=\"exclude\" placeholder=\"AD,SM,VA\"></label>\n\t\t<select id=\"shapeType\">\n\t\t\t<option value=\"square\" selected>View as squaremap</option> \n\t\t\t<option value=\"circle\">View as circlemap</option>\n\t\t\t<option value=\"diamond\">View as diamondmap</option>\n\t\t\t<option value=\"hexagon\">View as honeycomb</option>\n\t\t</select>\n\t\t<label><input id=\"invert\" type=\"checkbox\" />Invert Chart</label>\n\t\t<label><input id=\"dataLabels\" type=\"checkbox\" checked=\"checked\" />Data labels</label>\n\t\t<label><input id=\"enlarge\" type=\"checkbox\" />Enlarge</label>\n\t\t<button id=\"zoomOut\">Add space</button>\n\t</div>\n\t<div id=\"controls2\">\n\t\t<div class=\"checkboxContainer\">\n\t\t\t<label><input id=\"reverse\" type=\"checkbox\" />Reverse algorithm</label>\n\t\t\t<label><input id=\"labelCenter\" type=\"checkbox\" checked=\"checked\" />Use label center algorithm</label>\n\t\t</div>\n\t\t<label id=\"xResLabel\" for=\"xRes\">X resolution factor</label>\n\t\t<input type=\"range\" min=\"0.1\" max=\"10\" step=\"0.05\" value=\"1\" id=\"xRes\">\n\t\t<label id=\"yResLabel\" for=\"yRes\">Y resolution factor</label>\n\t\t<input type=\"range\" min=\"0.1\" max=\"10\" step=\"0.05\" value=\"1\" id=\"yRes\">\n\t</div>\n\t<div id=\"charts\">\n\t\t<div class=\"container\" id=\"tileContainer\"></div>\n\t\t<div class=\"verticalLine\"></div>\n\t\t<div class=\"container\" id=\"mapContainer\"></div>\n\t</div>\n\t<label>Tile data<textarea id=\"outputData\"></textarea></label>\n\t<label><input id=\"prettyprint\" type=\"checkbox\" />Pretty</label>\n</div>","npm":"// 安装\nnpm install highcharts@11.0.1 --save\n\n// import 模块 \nimport Jquery3.1.1.min from 'https://code.jquery.com/jquery-3.1.1.min.js';\nimport JqueryUi        from 'https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.js';\nimport Jquery.combobox from 'https://www.highcharts.com/samples/maps/11.0.1/demo/all-maps/jquery.combobox.js';\nimport Highcharts      from 'highcharts/highmaps';\nimport Tilemap         from 'highcharts/modules/tilemap';\nimport Exporting       from 'highcharts/modules/exporting';\nimport Index           from 'highcharts/mapdata/index';\n\n// 初始化模块\nJquery3.1.1.min(Highcharts);\nJqueryUi(Highcharts);\nJquery.combobox(Highcharts);\nTilemap(Highcharts);\nExporting(Highcharts);\nIndex(Highcharts);\n","scripts":["https://code.jquery.com/jquery-3.1.1.min.js","https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.js","https://www.highcharts.com/samples/maps/11.0.1/demo/all-maps/jquery.combobox.js","https://code.highcharts.com/maps/11.0.1/highmaps.js","https://code.highcharts.com/maps/11.0.1/modules/tilemap.js","https://code.highcharts.com/maps/11.0.1/modules/exporting.js","https://code.highcharts.com/11.0.1/mapdata/index.js"]}