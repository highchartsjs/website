{"js":"(function (H) {\n\n    const {\n        addEvent,\n        animObject,\n        Chart,\n        extend,\n        Series,\n        seriesTypes,\n        SVGElement,\n        Tick,\n        wrap\n    } = H;\n\n    class Morpher extends Highcharts.SVGElement {}\n\n    // Morph an SVG element into a different type of element\n    Highcharts.SVGElement.prototype.morph = function () {\n        // Return the point that is closest to an imaginary point directly above the\n        // shape. To avoid rotation when morphing.\n        const alignToTopPoint = (points, bBox) => {\n            // Find the point that is closest to an imaginary point directly above\n            // the bBox.\n            const topPoint = {\n                x: bBox.x + bBox.width / 2,\n                y: bBox.y - 100\n            };\n            let closestIdx;\n            let closestDist = Infinity;\n            for (let i = 0; i < points.length; i++) {\n                const dist = Math.pow(points[i].x - topPoint.x, 2) +\n                    Math.pow(points[i].y - topPoint.y, 2);\n                if (dist < closestDist) {\n                    closestDist = dist;\n                    closestIdx = i;\n                }\n            }\n            // Remove the points before the top point\n            const head = points.splice(0, closestIdx);\n            // And apply them at the end\n            points.push(...head);\n        };\n\n        const getPath = element => {\n            const totalLength = element.getTotalLength(),\n                count = 100,\n                points = [];\n            for (let i = 0; i < count; i++) {\n                points.push(\n                    element.getPointAtLength(i * totalLength / count)\n                );\n            }\n            alignToTopPoint(points, element.getBBox());\n            const path = points.map((point, i) => ([\n                i === 0 ? 'M' : 'L',\n                point.x,\n                point.y\n            ]));\n            path.push(['Z']);\n            return path;\n        };\n\n        // The element is not yet given a layout, skip it for now\n        try {\n            if (!this.element || this.element.getTotalLength() === 0) {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n\n        // Unset\n        const morphFrom = this.morphFrom;\n        delete this.morphFrom;\n\n        this.element.style.opacity = 0;\n\n        // Add a temporary morpher path element next to this element\n        setTimeout(() => {\n            const morpher = new Morpher();\n            morpher.init(this.renderer, 'path');\n            morpher\n                .attr({\n                    d: getPath(morphFrom),\n                    fill: this.element.getAttribute('fill'),\n                    stroke: this.element.getAttribute('stroke'),\n                    'stroke-width': this.element.getAttribute('stroke-width')\n                })\n                .add(this.parentGroup);\n\n            morpher.animate({\n                d: getPath(this.element)\n            }, extend(\n                animObject(this.renderer.globalAnimation),\n                {\n                    complete: () => {\n                        this.element.style.opacity = 1;\n                        morpher.destroy();\n                        morphFrom.remove();\n                    }\n                }\n            ));\n\n\n            morphFrom.style.opacity = 0;\n        }, 0);\n    };\n\n    SVGElement.prototype.sleep = function (key) {\n        this.renderer.sleeping[key] = this.element;\n    };\n\n    const getSleepKey = point => [\n        'point',\n        point.series.name || point.series.index,\n        point.x\n    ].join(',');\n\n    addEvent(Chart, 'afterGetContainer', e => {\n        e.target.renderer.sleeping = {};\n        e.target.renderer.sleepKeyQueue = [];\n    });\n\n    addEvent(SVGElement, 'afterInit', function () {\n        if (!(this instanceof Morpher) && this.renderer.sleepKeyQueue) {\n            const sleepKey = this.renderer.sleepKeyQueue.shift();\n\n            // Wake up existing element with the same key\n            if (sleepKey) {\n                this.morphFrom = this.renderer.sleeping[sleepKey];\n            }\n        }\n    });\n\n    wrap(SVGElement.prototype, 'afterSetters', function (proceed) {\n        proceed.call(this);\n        if (this.element && this.morphFrom && this.morph) {\n            this.morph();\n        }\n    });\n\n    // Points\n    const wrapDrawPoints = function (proceed) {\n        this.points.forEach(point => {\n            this.chart.renderer.sleepKeyQueue.push(getSleepKey(point));\n        });\n\n        proceed.call(this);\n\n        this.points.forEach(point => {\n            const { graphic } = point;\n            if (graphic) {\n                graphic.destroy = () => {\n                    graphic.sleep(getSleepKey(point));\n                    delete graphic.element;\n                    SVGElement.prototype.destroy.call(graphic);\n                };\n            }\n        });\n    };\n    wrap(seriesTypes.column.prototype, 'drawPoints', wrapDrawPoints);\n    wrap(seriesTypes.pie.prototype, 'drawPoints', wrapDrawPoints);\n    wrap(Series.prototype, 'drawPoints', wrapDrawPoints);\n\n    // Ticks\n    /*\n    wrap(Tick.prototype, 'renderGridLine', function (proceed) {\n        const axis = this.axis,\n            chart = axis.chart,\n            index = chart[axis.coll].indexOf(axis),\n            sleepKey = `gridline-${this.axis.coll}-${index}-${this.pos}`;\n\n        this.axis.chart.renderer.sleepKeyQueue.push(sleepKey);\n\n        proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n\n        const svgElement = this.gridLine;\n        if (svgElement) {\n            svgElement.destroy = () => {\n                svgElement.sleep(sleepKey);\n                delete svgElement.element;\n                SVGElement.prototype.destroy.call(svgElement);\n            };\n        }\n    });\n    wrap(Tick.prototype, 'renderMark', function (proceed) {\n        const axis = this.axis,\n            chart = axis.chart,\n            index = chart[axis.coll].indexOf(axis),\n            sleepKey = `tickmark-${this.axis.coll}-${index}-${this.pos}`;\n\n        this.axis.chart.renderer.sleepKeyQueue.push(sleepKey);\n\n        proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n\n        const svgElement = this.mark;\n        if (svgElement) {\n            svgElement.destroy = () => {\n                svgElement.sleep(sleepKey);\n                delete svgElement.element;\n                SVGElement.prototype.destroy.call(svgElement);\n            };\n        }\n    });\n    */\n\n    addEvent(Chart, 'redraw', e => {\n        const sleeping = e.target.renderer.sleeping;\n        Object.keys(sleeping).forEach(key => {\n            delete sleeping[key];\n        });\n        e.target.renderer.sleepKeyQueue.length = 0;\n\n    });\n}(Highcharts));\n\n// /////////////////////////////////////////////////////////////////////////////\n\nconst chart = Highcharts.chart('chart-container', {\n    chart: {\n        animation: {\n            duration: 1000\n        }\n    },\n    title: {\n        text: 'Morphed chart'\n    },\n    accessibility: {\n        enabled: false\n    },\n    colors: ['#cad2c5', '#84a98c', '#52796f', '#354f52'],\n    xAxis: {\n        showEmpty: false\n    },\n    yAxis: {\n        showEmpty: false\n    },\n    series: [{\n        type: 'column',\n        data: [1, 3, 2, 4],\n        colorByPoint: true\n    }]\n});\n\ndocument\n    .querySelector('#button-group-types')\n    .querySelectorAll('button')\n    .forEach(button => {\n        button.addEventListener('click', () => {\n            chart.series[0].update({ type: button.dataset.type }, false);\n            chart.redraw();\n        });\n    });\n\ndocument.getElementById('non-inverted')\n    .addEventListener('click', () => {\n        chart.update({\n            chart: {\n                inverted: false\n            }\n        });\n    });\n\n\ndocument.getElementById('inverted')\n    .addEventListener('click', () => {\n        chart.update({\n            chart: {\n                inverted: true\n            }\n        });\n    });\n\ndocument.getElementById('non-polar')\n    .addEventListener('click', () => {\n        chart.update({\n            chart: {\n                polar: false\n            }\n        });\n    });\n\n\ndocument.getElementById('polar')\n    .addEventListener('click', () => {\n        chart.update({\n            chart: {\n                polar: true\n            }\n        });\n    });\n","css":"#container,\n#chart-container {\n    max-width: 800px;\n    height: 400px;\n    margin: 1em auto;\n}\n","html":"\n\n<div id=\"chart-container\"></div>\n\n<div id=\"button-group-types\" class=\"btn-group\">\n    <button class=\"btn btn-outline-secondary\" data-type=\"column\">Column</button>\n    <button class=\"btn btn-outline-secondary\" data-type=\"pie\">Pie</button>\n    <button class=\"btn btn-outline-secondary\" data-type=\"scatter\">Scatter</button>\n</div>\n\n<div class=\"btn-group\">\n    <button class=\"btn btn-outline-secondary\" id=\"non-inverted\">Non-inverted</button>\n    <button class=\"btn btn-outline-secondary\" id=\"inverted\">Inverted</button>\n</div>\n\n<div class=\"btn-group\">\n    <button class=\"btn btn-outline-secondary\" id=\"non-polar\">Non-polar</button>\n    <button class=\"btn btn-outline-secondary\" id=\"polar\">Polar</button>\n</div>","npm":"// 安装\nnpm install highcharts@11.0.0 --save\n\n// import 模块 \nimport Highcharts     from 'highcharts';\nimport HighchartsMore from 'highcharts/highcharts-more';\n\n// 初始化模块\nHighchartsMore(Highcharts);\n","scripts":["https://code.highcharts.com/11.0.0/highcharts.js","https://code.highcharts.com/11.0.0/highcharts-more.js"]}