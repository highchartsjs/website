{"js":"const { isNumber, relativeLength, defined } = Highcharts;\n\nHighcharts.SVGRenderer.prototype.symbols.xsign = function (x, y, w, h) {\n    return ['M', x, y, 'L', x + w, y + h, 'M', x + w, y, 'L', x, y + h, 'z'];\n};\n\nfunction markerAttribs(point) {\n    const series = this,\n        options = series.options,\n        attribs = {},\n        pos = point.pos();\n\n    attribs.width = series.markerWidth;\n    attribs.height = series.markerHeight;\n    attribs.x = pos[0] - Math.round(attribs.width) / 2;\n    attribs.y = pos[1] - Math.round(attribs.height) / 2;\n    if (options.crisp) {\n        // Math.floor for #1843:\n        attribs.x = Math.floor(attribs.x);\n    }\n    return attribs;\n}\n\nfunction generatePnfData() {\n    const series = this,\n        options = series.options,\n        data = options.data,\n        boxSize = options.boxSize,\n        calculatedBoxSize = isNumber(boxSize) ?\n            boxSize : relativeLength(boxSize, data[0][4]),\n        finalData = series.finalData,\n        reversal = calculatedBoxSize * options.reversalAmount,\n        markerUp = options.markerUp;\n\n    series.calculatedBoxSize = calculatedBoxSize;\n\n    let upTrend;\n\n    function getLastPoint(pnfData) {\n        const y = pnfData[pnfData.length - 1].y;\n        return y[y.length - 1];\n    }\n\n    function pushPointGroup(x, y, up) {\n        const symbol = up ? markerUp : null;\n        finalData.push({\n            x,\n            y,\n            symbol\n        });\n    }\n\n    function pushNewPoint(y, upTrend, lastPoint) {\n        const currPointGroup = finalData[finalData.length - 1],\n            flipFactor = upTrend ? 1 : -1,\n            times = Math.floor(\n                flipFactor * (y - lastPoint) / calculatedBoxSize\n            );\n\n        for (let i = 1; i <= times; i++) {\n            const newPoint = lastPoint + flipFactor * (calculatedBoxSize * i);\n            currPointGroup.y.push(newPoint);\n        }\n    }\n\n    if (this.isDirtyData || (!this.isDirtyData && finalData.length === 0)) {\n\n        this.finalData.length = 0;\n\n        // Get first point and determine its symbol and trend\n        for (let i = 0; i < data.length; i++) {\n            const x = data[i][0],\n                close = data[i][4],\n                firstPoint = data[0][4];\n\n            if (close - firstPoint >= calculatedBoxSize) {\n                pushPointGroup(x, [close], true);\n                upTrend = true;\n                break;\n            }\n            if (firstPoint - close >= calculatedBoxSize) {\n                pushPointGroup(x, [close], false);\n                upTrend = false;\n                break;\n            }\n        }\n\n        data.forEach(point => {\n            const x = point[0],\n                close = point[4],\n                lastPoint = getLastPoint(finalData);\n\n            if (upTrend) {\n\n                if (close - lastPoint >= calculatedBoxSize) { // Add point going UP\n                    pushNewPoint(close, upTrend, lastPoint);\n                }\n\n                if (lastPoint - close >= reversal) { // Handle reversal\n                    upTrend = false;\n\n                    pushPointGroup(x, [], false);\n                    pushNewPoint(close, upTrend, lastPoint);\n                }\n            }\n\n            if (!upTrend) {\n\n                if (lastPoint - close >= calculatedBoxSize) { // Add point going DOWN\n                    pushNewPoint(close, upTrend, lastPoint);\n                }\n\n                if (close - lastPoint >= reversal) { // Handle reversal\n                    upTrend = true;\n\n                    pushPointGroup(x, [], true);\n                    pushNewPoint(close, upTrend, lastPoint);\n                }\n            }\n        });\n    }\n\n    // Process the finalData to groupData return format\n    const groupedXData = [],\n        groupedYData = [],\n        groupMap = [];\n\n    finalData.forEach(point => {\n        const x = point.x;\n\n        point.y.forEach(y => {\n            groupedXData.push(x);\n            groupedYData.push(+y.toFixed(2));\n            groupMap.push({\n                start: x,\n                length: point.y.length,\n                options: {\n                    marker: point.symbol\n                }\n            });\n        });\n    });\n\n    return {\n        groupedXData,\n        groupedYData,\n        groupMap\n    };\n}\n\nHighcharts.wrap(Highcharts.Axis.prototype, 'getClosest', function (proceed) {\n    let ret = proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n\n    const pnfSeries = this.series.filter(series => series.is('pointandfigure'));\n\n    pnfSeries.forEach(() => {\n        if (this.categories) {\n            ret = 1;\n        } else {\n            this.series.forEach(function (series) {\n                const seriesClosest = series.closestPointRange,\n                    visible = series.visible ||\n                        !series.chart.options.chart.ignoreHiddenSeries;\n\n                if (defined(seriesClosest) && visible) {\n                    ret = defined(ret) ?\n                        Math.min(ret, seriesClosest) :\n                        seriesClosest;\n                }\n            });\n        }\n    });\n    return ret;\n});\n\n// eslint-disable-next-line no-underscore-dangle\nHighcharts.wrap(Highcharts._modules['Core/Series/Series.js'].prototype, 'groupData', function (proceed) {\n    if (this.is('pointandfigure')) {\n        return generatePnfData.apply(\n            this, Array.prototype.slice.call(arguments, 1\n            ));\n    }\n    return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n});\n\nHighcharts.seriesType(\n    'pointandfigure',\n    'scatter', {\n    // Options\n        boxSize: '5%',\n        reversalAmount: 3,\n        tooltip: {\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> ' +\n                '<b> {series.name}</b><br/>' +\n                'Close: {point.y}<br/>',\n            headerFormat: ''\n        },\n        turboThreshold: 0,\n        groupPadding: 0.2,\n        pointPadding: 0.1,\n        pointRange: null,\n        dataGrouping: {\n            groupAll: true,\n            enabled: true,\n            forced: true\n        },\n        markerUp: {\n            symbol: 'xsign',\n            lineColor: 'green',\n            lineWidth: 2\n        },\n        marker: {\n            symbol: 'circle',\n            fillColor: 'transparent',\n            lineColor: 'red',\n            lineWidth: 2\n        }\n    }, {\n        // Series prototype\n        takeOrdinalPosition: true,\n        finalData: [],\n        getColumnMetrics:\n            Highcharts.seriesTypes.column.prototype.getColumnMetrics,\n        markerAttribs,\n        generatePnfData,\n        translate() {\n            const metrics = this.getColumnMetrics(),\n                calculatedBoxSize = this.calculatedBoxSize;\n            this.markerWidth =\n                metrics.width + metrics.paddedWidth + metrics.offset;\n            this.markerHeight =\n                this.yAxis.toPixels(0) - this.yAxis.toPixels(calculatedBoxSize);\n            return Highcharts.Series.prototype.translate.call(this);\n        }\n    }, {\n        // Point prototype\n    }\n);\n\nHighcharts.getJSON('https://demo-live-data.highcharts.com/aapl-ohlc.json', function (data) {\n\n    Highcharts.stockChart('container', {\n        chart: {\n            height: 800\n        },\n        title: {\n            text: 'AAPL stock price - Point and Figure'\n        },\n        series: [{\n            name: 'AAPL',\n            type: 'pointandfigure',\n            data\n        }]\n    });\n});\n","css":"#container {\n    min-width: 310px;\n    max-width: 800px;\n    margin: 0 auto;\n}\n","html":"\n<div id=\"container\"></div>","npm":"// 安装\nnpm install highcharts@11.0.1 --save\n\n// import 模块 \nimport Highcharts from 'highcharts/highstock';\nimport Data       from 'highcharts/modules/data';\n\n// 初始化模块\nData(Highcharts);\n","scripts":["https://code.highcharts.com/stock/11.0.1/highstock.js","https://code.highcharts.com/stock/11.0.1/modules/data.js"]}